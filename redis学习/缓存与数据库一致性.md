## 缓存与数据库一致性讨论

原文: [美团二面：Redis与MySQL双写一致性如何保证?](https://juejin.cn/post/6964531365643550751)

#### 三种一致性级别

- **强一致性:** 该一致性级别最符合用户直觉，即要求系统写入什么，读出来的也会是什么。用户体验很好，但是对系统性能有很大影响；
- **弱一致性:**该一致性级别约束了系统在写入成功后，不承诺立即可以读到写入的值，也不承诺多久之后数据能够达到一致，但会尽可能地保证到某个时间级别（比如秒级别）后，数据能够达到一致状态;
- **最终一致性**:终一致性是弱一致性的一个特例，系统会保证在一定时间内，能够达到一个数据一致的状态。这里之所以将最终一致性单独提出来，是因为它是**弱一致性中非常推崇的一种一致性模型，也是业界在大型分布式系统的数据一致性上比较推崇的模型**。

#### 三种经典的缓存模式

- `CacheAside Pattern`(**<mark style="color:red">最常用</mark>**)
- `ReadThrough/WriteThrough`
- `CacheBack/WriteBack`

##### `CacheAside Pattern`：旁路缓存模式

- **`CacheAside Pattern`读流程**
  - 读的时候，先读缓存，缓存命中则直接返回;
  - 缓存没命中，则读取数据库，从数据库中读取出数据，然后放回缓存，同时返回数据;
- **`CacheAside Pattern`写流程**
  - 更新时，先更数据库，而后删除缓存。

##### `ReadThrough/WriteThrough Pattern`:(读写穿透)

`ReadThrough/WriteThrough`模式中，服务端把缓存作为主要存储。应用程序只和数据库缓存层交互，交互都有**抽象缓存层完成**。

**ReadThrough**

- 从缓存读取数据，缓存命中则直接返回;
- 缓存没命中，则读取数据库，从数据库中读取出数据，然后放回缓存，同时返回数据;

这个流程好`CacheAside`很像？但其实`ReadThrough`中多了一层`Cache Provider`。`Cache Provider`与缓存、数据库做交互。

`ReadThrough`是在`CacheAside`之上进行了封装，它会让程序代码变得简洁，同时减少数据源的负载。

![image-20220217150851273](https://my-typora-pictures-1252258460.cos.ap-guangzhou.myqcloud.com/img/image-20220217150851273.png)

**WriteThrough**

写请求也是由 `CacheProvider`这一层来完成 数据库和数据缓存的更新。

![image-20220217151656176](https://my-typora-pictures-1252258460.cos.ap-guangzhou.myqcloud.com/img/image-20220217151656176.png)

##### `CacheBack/WriteBack  Pattern`:异步缓存批量回写

`WriteBack`跟`ReadThrough/WriteThrough`有相似的地方，都是由`Cache Provider`来负责缓存和数据库的读写。
它们又有个很大的不同:`Read/Write-Through`是同步更新缓存和数据的，**`WriteBack`则是只更新缓存，不直接更新数据库，通过批量异步的方式来更新数据库**。

![image-20220217152436218](https://my-typora-pictures-1252258460.cos.ap-guangzhou.myqcloud.com/img/image-20220217152436218.png)



MySQL的`InnoDB Buffer Pool`机制就是使用该模式。

`CacheAside`是最常用的模式，下面来探讨一下`CacheAside`模式下 缓存和数据库操作的几种顺序。

#### 缓存与数据库操作顺序 和 不一致出现的情况

1. 先更新缓存，后更新数据库

   不一致情况: 

   - 业务方无法保证两个写操作都成功。当更新缓存成功，更新数据库失败时，数据库中就是旧数据;
   - A B两个线程同时更新一行数据，A更新缓存=> B更新缓存=>B更新数据库=>A更新缓存。此时数据库 和 缓存数据不一致；

2. 先更新数据库，后更新缓存

   不一致情况:

   - A B两个线程同时更新一行数据，A更新数据库=> B更新数据库=>B更新缓存=>A更新缓存。此时数据库 和 缓存数据不一致；

3. 先更新数据库，再删除缓存

   不一致情况:

   - 更新数据库成功，删除缓存失败，此时数据库 和 缓存数据不一致;

4. 先删除缓存，再写数据库

   不一致情况:

   - A B两个线程，A删除缓存=> B从数据库中读取数据=>B更新旧值到缓存=>A更新数据库。此时数据库 和 缓存数据不一致；

从上面的分析中可以看出，无论是先写缓存还是先写数据库，都可能出现数据库和缓存不一致的情况。

不过**相比删除缓存**，**更新缓存** 有一点劣势:

- 如果写入的缓存值，经过复杂的计算才得到的话。更新缓存频率高，浪费性能(其实我感觉，这种频繁更新场景，MySQL也扛不住哇)；

**先更新数据库，再删除缓存  比较好的一个点是：删除缓存只有在 删除缓存失败时，数据才不一致。这种情况蛮少的。**

##### 行业常见两种解决方案

1) 缓存延迟双删策略;
2) 异步更新策略;

#### 延迟删除策略

1. 先删除缓存;
2. 再更新数据库;
3. 休眠一会儿(如100ms)，再次删除缓存;

为什么需要休眠一段时间呢？

主要是防止: A删除缓存=> B从数据库中读取数据=>A更新数据库=>A再次删除缓存=>B更新旧值到缓存，这种情况下数据不一致。休眠一段时间，这段时间内，B极大概率已经将旧值更新到缓存，此时A再删除缓存就很合理。

延迟双删策略 虽然解决了上面讨论数据不一致的问题，但是面临如下问题:

- 休眠一段时间 会对性能造成影响；
- 在对第二次删除缓存失败后，还是有可能出现数据不一致的情况。需要业务方实现重试删除机制。

#### 重试删除机制

![image-20220217205934211](/Users/lukexwang/Library/Application Support/typora-user-images/image-20220217205934211.png)

#### 异步更新缓存策略(基于订阅Binlog的同步机制)

异步更新缓存策略通常会使用一个异步同步组件(比如 canal 或者我司的 MySync)， 通过解析从库的 binlog 获取数据，并通过消息队列将其串行化写入到缓存。

![image-20220217210741596](/Users/lukexwang/Library/Application Support/typora-user-images/image-20220217210741596.png)

写流程:

1.  先删除缓存，再写数据库
2. 额外组件通过解析从库 binlog， 将写操作发送到消息队列
3. 缓存从消息队列中消费，更新缓存

读流程:

1. 先从缓存读取
2. 如果缓存未命中， 从数据库读取， 将数据发送到消息队列。
3. 缓存从消息队列消费，更新缓存。

异步更新缓存策略通过消息队列的方式将并行化的操作串行化，从而解决了并发问题。但是也引入一些其他问题，比如缓存相对主库落后延迟较大。

#### 缓存的几个问题

参考文章: [Redis 缓存雪崩、击穿、穿透](https://segmentfault.com/a/1190000022029639)

##### 缓存穿透

缓存穿透是指查询数据库和缓存都不存在的数据。

我们数据库的 id 都是1开始自增上去的，如发起为id值为 -1 的数据或 id 为特别大不存在的数据。这时的用户很可能是攻击者，攻击会导致数据库压力过大，严重会击垮数据库。

1. 所以需要做充足的输入参数校验、用户鉴权。

如某个分页查询的接口，但是你没对分页参数的大小做限制，调用的人万一一口气查 Integer.MAX_VALUE 一次请求就要你几秒，多几个并发你不就挂了么？是公司同事调用还好大不了发现了改掉，但是如果是黑客或者竞争对手呢？

2. 从缓存取不到的数据，在数据库中也没有取到，这时也可以将对应Key的Value对写为null、位置错误、稍后重试这样的值具体取啥问产品，或者看具体的场景，缓存有效时间可以设置短点，如30秒。

3. 这样可以防止攻击用户反复用同一个id暴力攻击，但是我们要知道正常用户是不会在单秒内发起这么多次请求的，那网关层**Nginx**有配置项，可以让运维大大对单个IP每秒访问次数超出阈值的IP都拉黑。
4. **Redis**还有一个高级用法**布隆过滤器（Bloom Filter）**这个也能很好的防止缓存穿透的发生，原理也很简单就是利用高效的数据结构和算法快速判断出你这个Key是否在数据库中存在，不存在你return就好了，存在你就去查了DB刷新缓存再return。

##### 缓存击穿

如果某些 Key 可能会在某些时间点被超高并发地访问，则它是一种非常“热点”的数据。缓存击穿是指大量的请求同时查询一个失效的热点数据，导致请求全部转发到数据库。

一个Key非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个Key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一个完好无损的桶上凿开了一个洞。

解决方法: 

- 设置热点数据永远不过期;
- 也可以使用singleflight模式，原理就是当缓存失效的时候，相同 key 的请求只放行一个到后台数据库，减少请求压力。多线程获取应该用锁限制只有一个线程回源;

##### 缓存雪崩

缓存雪崩是指某一时刻发生大规模的缓存失效的情况，比如缓存故障或者缓存采用相同的过期时间，缓存在某一时刻同时失效， 请求全部转发给数据库。

解决方法：

- 把key的过期时间都加一个随机值，确保数据不会在同一时间大面积过期;
- 加锁或者队列的的方式保证不会同时对数据库尽量大量读写;

##### 缓存污染

爬虫批量抓取导致缓存了很多冷数据;

##### 缓存预热

- 数据量不大的时候，工程启动的时候进行加载缓存动作;
- 数据量大的时候，设置一个定时任务脚本，进行缓存的刷新;
- 数据量太大的时候，优先保证热点数据进行提前加载到缓存.

##### 热点key

热点 key 导致单机 redis 压力陡增，通过 key hash分散热点或者使用本地缓存的方式(多级缓存)，减小 redis 压力;