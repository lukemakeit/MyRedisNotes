## 基础

代码中字符串多行文本:

```python
print('''line1
line2
line3''')
```

python中Bool值表示:`True` 或`False`。

```python
>>> True
True
>>> False
False
>>> 3 > 2
True
>>> 3 > 5
False
```

python中的与或非是`and`、`or`、`not`:

```python
>>> not True
False
>>> 5 > 3 and 3 > 1
True
>>> True or False
True
>>> not False
True
```

python中空值是`None`;

#### 字符串

- Python对`bytes`类型的数据用带`b`前缀的单引号或双引号表示:`x = b'ABC'`

- `len()`函数计算的是`str`的字符数，如果换成`bytes`，`len()`函数就计算字节数:

```python
>>> len('中文')
2
>>> len(b'ABC')
3
>>> len(b'\xe4\xb8\xad\xe6\x96\x87')
6
>>> len('中文'.encode('utf-8'))
6
```

- 源文件中如果包含中文，为了源码解释器按UTF-8编码读取，我们通常在文件开头写上这两行

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
```

- 字符串输出的格式化:

  ```python
  >>> 'Hello, %s' % 'world'
  'Hello, world'
  >>> 'Hi, %s, you have $%d.' % ('Michael', 1000000)
  'Hi, Michael, you have $1000000.'
  ```

  **如果你不太确定应该用什么，`%s`永远起作用，它会把任何数据类型转换为字符串**：

  ```python
  >>> 'Age: %s. Gender: %s' % (25, True)
  'Age: 25. Gender: True'
  ```

- 替换子串:

  ```python
  >>> line="hello world"
  >>> a=line.replace("world","luke") 
  >>> line #line是不变的
  'hello world'
  >>> a
  'hello luke'
  ```
  
- 字符串切割:split

  ```python
  >>> a='''
  ... 11.148.208.170
  ... 11.148.213.161
  ... '''
  >>> a.split("\n")
  ['', '11.148.208.170', '11.148.213.161', '']
  >>> a.strip().split("\n")
  ['11.148.208.170', '11.148.213.161']
  ```
  
- 字符串拼接:join

  ```python
  >>> classmates = ['Michael', 'Bob', 'Tracy']
  >>> ",".join(classmates)
  'Michael,Bob,Tracy'
  
  >>> str1= ('1', '2', '3', '3')
  >>> "-".join(str1)
  '1-2-3-3'
  
  #但是小心这个使用方法。比如直接用string去join
  >>> ip="11.148.208.170"
  >>> "\n".join(ip)
  '1\n1\n.\n1\n4\n8\n.\n2\n0\n8\n.\n1\n7\n0'
  ```

#### list 

```python
>>> classmates = ['Michael', 'Bob', 'Tracy']
>>> classmates
['Michael', 'Bob', 'Tracy']
>>> len(classmates)
3
>>> classmates[2]
'Tracy'
>>> classmates[-1]
'Tracy'
>>> classmates.append('Adam') #追加元素
>>> classmates
['Michael', 'Bob', 'Tracy', 'Adam']

>>> language_tuple = ('Spanish', 'Portuguese') # 元组
>>> language_set = {'Chinese', 'Japanese'} #集合
>>> 
>>> classmates.extend(language_tuple) #将元组中多个值追加到 classmates中
>>> classmates
['Michael', 'Bob', 'Tracy', 'Adam', 'Spanish', 'Portuguese']
>>> classmates.extend(language_set) #将集合中多个值追加到 classmates中
>>> 
>>> classmates
['Michael', 'Bob', 'Tracy', 'Adam', 'Spanish', 'Portuguese', 'Japanese', 'Chinese']

>>> classmates.insert(1, 'Jack') #更新指定index位置的元素
>>> classmates
['Michael', 'Jack', 'Bob', 'Tracy', 'Adam']

>>> classmates.pop() # 删除list末尾的元素
'Adam'
>>> classmates
['Michael', 'Jack', 'Bob', 'Tracy']

>>> classmates.pop(1) #删除指定位置的元素
'Jack'
>>> classmates
['Michael', 'Bob', 'Tracy']

>>> classmates[1] = 'Sarah' #某个元素替换成别的元素
>>> classmates
['Michael', 'Sarah', 'Tracy']

>>> L = ['Apple', 123, True] #可以保存不同类型的数据

>>> s = ['python', 'java', ['asp', 'php'], 'scheme']
>>> len(s)
4
```

#### tuple:元组

tuple和list非常类似，但是tuple一旦初始化就不能修改，比如同样是列出同学的名字。

```python
>>> classmates = ('Michael', 'Bob', 'Tracy')
```

#### Dict

```python
>>> d = {'Michael': 95, 'Bob': 75, 'Tracy': 85}
>>> d['Michael']
95

>>> d['Adam'] = 67 #重新赋值
>>> d['Adam']
67

#更新
>>> d.update({'zhangsan':20,'lisi':33})
>>> d
{'Michael': 95, 'Bob': 75, 'Tracy': 85, 'zhangsan': 20, 'lisi': 33, 'Adam': 67}
```

要避免key不存在的错误，有两种办法，一是通过`in`判断key是否存在：

```python
>>> 'Thomas' in d
False
```

二是通过dict提供的`get()`方法，如果key不存在，可以返回`None`，或者自己指定的value：

```python
>>> d.get('Thomas') #注意：返回None的时候Python的交互环境不显示结果。
>>> d.get('Thomas', -1)
-1
```

要删除一个key，用`pop(key)`方法，对应的value也会从dict中删除:

```python
>>> d.pop('Bob')
75
>>> d
{'Michael': 95, 'Tracy': 85}
```

迭代:

```python
>>> d = {'a': 1, 'b': 2, 'c': 3}
>>> for key in d:
...     print(key)
...
a
c
b

#获取到key/value
>>> d = {'x': 'A', 'y': 'B', 'z': 'C' }
>>> for k, v in d.items():
...     print(k, '=', v)
...
y = B
x = A
z = C
```

#### Set

set和dict类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在set中，没有重复的key。

要创建一个set，需要提供一个list作为输入集合：

```python
>>> s = set([1, 2, 3])
>>> s
{1, 2, 3}

>>> s = set([1, 1, 2, 2, 3, 3])
>>> s
{1, 2, 3}

>>> s.add(4) #添加元素
>>> s
{1, 2, 3, 4}

>>> s.remove(4) #删除元素
>>> s
{1, 2, 3}

#求交集 并集
>>> s1 = set([1, 2, 3])
>>> s2 = set([2, 3, 4])
>>> s1 & s2
{2, 3}
>>> s1 | s2
{1, 2, 3, 4}
```

#### 条件判断

```python
age = 3
if age >= 18:
    print('adult')
elif age >= 6:
    print('teenager')
else:
    print('kid')
```

一行表达其他语言中`?:`语义:

```py
fruit = 'Apple'
isApple = True if fruit == 'Apple' else False
```

#### 循环

```python
names = ['Michael', 'Bob', 'Tracy']
for name in names:
    print(name)
```

如果要计算1-100的整数之和，从1写到100有点困难，幸好Python提供一个`range()`函数，可以生成一个整数序列，再通过`list()`函数可以转换为list。比如`range(5)`生成的序列是从0开始小于5的整数：

```python
>>> list(range(5))
[0, 1, 2, 3, 4]

# range(101)就可以生成0-100的整数序列，计算如下：
sum = 0
for x in range(101):
    sum = sum + x
print(sum)
```

while循环:

```python
sum = 0
n = 99
while n > 0:
    sum = sum + n
    n = n - 2
print(sum)
```

break 和 continue:

```python
n = 1
while n <= 100:
    if n > 10: # 当n = 11时，条件满足，执行break语句
        break # break语句会结束当前循环
    print(n)
    n = n + 1
print('END')

n = 0
while n < 10:
    n = n + 1
    if n % 2 == 0: # 如果n是偶数，执行continue语句
        continue # continue语句会直接继续下一轮循环，后续的print()语句不会执行
    print(n)
```

#### 函数

```python
def my_abs(x):
    if x >= 0:
        return x
    else:
        return -x
```

空函数:

```python
def nop():
    pass
```

自定义参数类型检查:

```python
def my_abs(x):
    if not isinstance(x, (int, float)):
        raise TypeError('bad operand type')
    if x >= 0:
        return x
    else:
        return -x
```

返回多个值:

```python
import math

def move(x, y, step, angle=0):
    nx = x + step * math.cos(angle)
    ny = y - step * math.sin(angle)
    return nx, ny

>>> x, y = move(100, 100, 60, math.pi / 6)
>>> print(x, y)
151.96152422706632 70.0

>>> r = move(100, 100, 60, math.pi / 6)
>>> print(r)
(151.96152422706632, 70.0) #返回的其实是truple类型
```

默认参数:

```python
def power(x, n=2):
    s = 1
    while n > 0:
        n = n - 1
        s = s * x
    return s
>>> power(5)
25
>>> power(5, 2)
25
```

<mark style="color:red">定义默认参数要牢记一点：默认参数必须指向不变对象！</mark>

```python
def add_end(L=[]):
    L.append('END')
    return L
>>> add_end() #第一次调用
['END']
>>> add_end() #第二次调用
['END', 'END']
>>> add_end() #第三次调用
['END', 'END', 'END']
```

原因解释如下：

Python函数在定义的时候，默认参数`L`的值就被计算出来了，即`[]`，因为默认参数`L`也是一个变量，它指向对象`[]`，每次调用该函数，如果改变了`L`的内容，则下次调用时，默认参数的内容就变了，不再是函数定义时的`[]`了。

正确的姿势:

```python
def add_end(L=None):
    if L is None:
        L = []
    L.append('END')
    return L
>>> add_end()  #第一次调用
['END']
>>> add_end()  #第二次调用
['END']
```

可变参数:

给定一组数字a，b，c……，请计算a2 + b2 + c2 + ……

由于参数个数不确定，我们首先想到可以把a，b，c……作为一个list或tuple传进来，这样，函数可以定义如下：

```python
def calc(numbers):
    sum = 0
    for n in numbers:
        sum = sum + n * n
    return sum
# 调用的时候，需要先组装出一个list或tuple
>>> calc([1, 2, 3])
14
>>> calc((1, 3, 5, 7))
84
#我们把函数的参数改为可变参数。可变参数在函数调用时自动组装为一个tuple
def calc(*numbers):
    sum = 0
    for n in numbers:
        sum = sum + n * n
    return sum
>>> calc(1, 2)
5
>>> calc()
0
# Python允许你在list或tuple前面加一个*号，把list或tuple的元素变成可变参数传进去
>>> nums = [1, 2, 3]
>>> calc(*nums)
14
```

关键字参数:

关键字参数允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict。请看示例：

```python
def person(name, age, **kw):
    print('name:', name, 'age:', age, 'other:', kw)

>>> person('Michael', 30)
name: Michael age: 30 other: {}

>>> person('Bob', 35, city='Beijing')
name: Bob age: 35 other: {'city': 'Beijing'}

>>> person('Adam', 45, gender='M', job='Engineer')
name: Adam age: 45 other: {'gender': 'M', 'job': 'Engineer'}

>>> extra = {'city': 'Beijing', 'job': 'Engineer'}
>>> person('Jack', 24, **extra)
name: Jack age: 24 other: {'city': 'Beijing', 'job': 'Engineer'}
```

参数组合:

在Python中定义函数，可以用必选参数、默认参数、可变参数、关键字参数和命名关键字参数，这5种参数都可以组合使用。但是请注意，参数定义的顺序必须是：必选参数、默认参数、可变参数、命名关键字参数和关键字参数。

```python
def f1(a, b, c=0, *args, **kw):
    print('a =', a, 'b =', b, 'c =', c, 'args =', args, 'kw =', kw)
    
>>> f1(1, 2, 3, 'a', 'b')
a = 1 b = 2 c = 3 args = ('a', 'b') kw = {}
>>> f1(1, 2, 3, 'a', 'b', x=99)
a = 1 b = 2 c = 3 args = ('a', 'b') kw = {'x': 99}
```

**函数注解**
为函数的参数、返回值做注解。

```python
def f(ham:str,egg:str='eggs')->str:
  pass
print(f.__annotations__)

输出结果:
{'ham': <class 'str'>, 'egg': <class 'str'>, 'return': <class 'str'>}
```

- 给函数中的参数做注解的方法是在形参后添加冒号`:` 后接需添加的注解(如上面的`str`、`int`等);
- 给返回值做注解的方式是def语句结尾的括号`)`和`:`之间添加`->注解内容`;
- **注意: 如果参数有默认值，参数注解位于冒号和等号之间。比如 eggs:str='eggs'，它表示 eggs 参数的默认值为 'eggs'，添加的注解为 str**
- **注意，函数注解没有任何语法上的意义，只是为函数参数和返回值做注解，并在运行获取这些注解，仅此而已。换句话说，为函数做的注解，Python不做检查，不做强制，不做验证，什么操作都不做，函数注解对Python解释器没任何意义**

示例:
````python
def square(number:"一个数字")->"返回number的平方":
  return number**2
print(square(10))
print(square.__annotations__)

输出结果:
100
{'number': '一个数字', 'return': '返回number的平方'}
````

#### 切片操作

```python
L = ['Michael', 'Sarah', 'Tracy', 'Bob', 'Jack']
>>> L[0:3] #取前三个元素
['Michael', 'Sarah', 'Tracy']
>>> L[:3] #取前三个元素
['Michael', 'Sarah', 'Tracy']

>>> L[1:3]
['Sarah', 'Tracy']

>>> L = list(range(100))
>>> L
[0, 1, 2, 3, ..., 99]
>>> L[:10] #前10个元素
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
>>> L[-10:] #后10个元素
[90, 91, 92, 93, 94, 95, 96, 97, 98, 99]

>>> L[:10:2] #前10个数，每两个取一个
[0, 2, 4, 6, 8] 
```

#### 列表生成式

```python
>>> L = []
>>> for x in range(1, 11):
...    L.append(x * x)
...
>>> L
[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]

>>> [x * x for x in range(1, 11)] #更优雅的写法
[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]
```

for循环后面还可以加上if判断，这样我们就可以筛选出仅偶数的平方：

```python
>>> [x * x for x in range(1, 11) if x % 2 == 0]
[4, 16, 36, 64, 100]
```

不能给最后的if加上else:

```python
>>> [x for x in range(1, 11) if x % 2 == 0 else 0]
  File "<stdin>", line 1
    [x for x in range(1, 11) if x % 2 == 0 else 0]
                                              ^
SyntaxError: invalid syntax
```

因为跟在`for`后面的`if`是一个筛选条件，不能带`else`，否则如何筛选？

童鞋发现把`if`写在`for`前面必须加`else`，否则报错：

```
>>> [x if x % 2 == 0 for x in range(1, 11)]
  File "<stdin>", line 1
    [x if x % 2 == 0 for x in range(1, 11)]
                       ^
SyntaxError: invalid syntax

>>> [x if x % 2 == 0 else -x for x in range(1, 11)]
[-1, 2, -3, 4, -5, 6, -7, 8, -9, 10]
```

在一个列表生成式中，`for`前面的`if ... else`是表达式，而`for`后面的`if`是过滤条件，不能带`else`。

再如:

```python
>>> d = {'x': 'A', 'y': 'B', 'z': 'C' }
>>> for k, v in d.items():
...     print(k, '=', v)
...
y = B
x = A
z = C

>>> d = {'x': 'A', 'y': 'B', 'z': 'C' }
>>> [k + '=' + v for k, v in d.items()]
['y=B', 'x=A', 'z=C']

>>> L = ['Hello', 'World', 'IBM', 'Apple']
>>> [s.lower() for s in L]
['hello', 'world', 'ibm', 'apple']
```

使用内建的`isinstance`函数可以判断一个变量是不是字符串：

```python
>>> x = 'abc'
>>> y = 123
>>> isinstance(x, str)
True
>>> isinstance(y, str)
False

# 如果list中既包含字符串，又包含整数，由于非字符串类型没有lower()方法，所以列表生成式会报错
>>> L = ['Hello', 'World', 18, 'Apple', None]
>>> [s.lower() for s in L]
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "<stdin>", line 1, in <listcomp>
AttributeError: 'int' object has no attribute 'lower'

# 所以就可以用列表生成式来筛选掉不需要的元素
L1 = ['Hello', 'World', 18, 'Apple', None]
L2 = [s.lower() for s in L1 if isinstance(s,str) == True]
print(L2)
if L2 == ['hello', 'world', 'apple']:
    print('测试通过!')
else:
    print('测试失败!')
```

#### 生成器generator

通过列表生成式，我们可以直接创建一个列表。但是，受到内存限制，列表容量肯定是有限的。而且，创建一个包含100万个元素的列表，不仅占用很大的存储空间，如果我们仅仅需要访问前面几个元素，那后面绝大多数元素占用的空间都白白浪费了。
所以，如果列表元素可以按照某种算法推算出来，那我们是否可以在循环的过程中不断推算出后续的元素呢？这样就不必创建完整的list，从而节省大量的空间。在Python中，这种一边循环一边计算的机制，称为生成器：generator。
要创建一个generator，有很多种方法。
**第一种方法很简单，只要把一个列表生成式的`[]`改成`()`，就创建了一个generator:**

```python
>>> L = [x * x for x in range(10)]
>>> L
[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
>>> g = (x * x for x in range(10)) #创建L和g的区别仅在于最外层的[]和()，L是一个list，而g是一个generator

>>> next(g)
0
>>> next(g)
1
>>> next(g)
4
>>> next(g)
9
>>> next(g)
16
>>> next(g)
25
...
>>> next(g)
81
>>> next(g)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
StopIteration

# 更一般的情况
>>> g = (x * x for x in range(10))
>>> for n in g:
...     print(n)
... 
0
1
4
...
```

**第二种方法 函数中添加`yield`关键字**

```python
def fib(max):
    n, a, b = 0, 0, 1
    while n < max:
        yield b
        a, b = b, a + b
        n = n + 1
    return 'done'
```

如果一个函数定义中包含`yield`关键字，那么这个函数就不再是一个普通函数，而是一个generator函数，调用一个generator函数将返回一个generator:

```python
>>> f = fib(6)
>>> f
<generator object fib at 0x104feaaa0>
```

普通函数是顺序执行，遇到`return`语句或者最后一行函数语句就返回。**而变成generator的函数，在每次调用`next()`的时候执行，遇到`yield`语句返回，再次执行时从上次返回的`yield`语句处继续执行**。

```python
def odd():
    print('step 1')
    yield 1
    print('step 2')
    yield(3)
    print('step 3')
    yield(5)
>>> o = odd()
>>> next(o)
step 1
1
>>> next(o)
step 2
3
>>> next(o)
step 3
5
>>> next(o)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
StopIteration
```

<mark style="color:red">调用generator函数会创建一个generator对象，多次调用generator函数会创建多个相互独立的generator。</mark>

```python
>>> next(odd())
step 1
1
>>> next(odd())
step 1
1
>>> next(odd())
step 1
1
```

原因在于`odd()`会创建一个新的generator对象，**上述代码实际上创建了3个完全独立的generator，对3个generator分别调用`next()`当然每个都会返回第一个值。**
正确的写法是创建一个generator对象，然后不断对这一个generator对象调用`next()`：

```python
>>> g = odd()
>>> next(g)
step 1
1
>>> next(g)
step 2
3
>>> next(g)
step 3
5
```

#### 迭代器

可以直接作用于`for`循环的数据类型有以下几种：

- 一类是集合数据类型，如`list`、`tuple`、`dict`、`set`、`str`等；
- 一类是`generator`，包括生成器和带`yield`的generator function。
- 这些可以直接作用于`for`循环的对象统称为可迭代对象：`Iterable`。可以使用`isinstance()`判断一个对象是否是`Iterable`对象：

```python
>>> from collections.abc import Iterable
>>> isinstance([], Iterable)
True
>>> isinstance({}, Iterable)
True
>>> isinstance('abc', Iterable)
True
>>> isinstance((x for x in range(10)), Iterable)
True
>>> isinstance(100, Iterable)
False
```

- 可以被`next()`函数调用并不断返回下一个值的对象称为迭代器：`Iterator`。可以使用`isinstance()`判断一个对象是否是`Iterator`对象：

```python
>>> from collections.abc import Iterator
>>> isinstance((x for x in range(10)), Iterator)
True
>>> isinstance([], Iterator)
False
>>> isinstance({}, Iterator)
False
>>> isinstance('abc', Iterator)
False
```

**生成器都是`Iterator`对象，但`list`、`dict`、`str`虽然是`Iterable`，却不是`Iterator`。**

**把`list`、`dict`、`str`等`Iterable`变成`Iterator`可以使用`iter()`函数:**

```python
>>> isinstance(iter([]), Iterator)
True
>>> isinstance(iter('abc'), Iterator)
True
```

为什么`list`、`dict`、`str`等数据类型不是`Iterator`？

这是因为Python的`Iterator`对象表示的是一个数据流，Iterator对象可以被`next()`函数调用并不断返回下一个数据，直到没有数据时抛出`StopIteration`错误。可以把这个数据流看做是一个有序序列，但我们却不能提前知道序列的长度，只能不断通过`next()`函数实现按需计算下一个数据，所以`Iterator`的计算是惰性的，只有在需要返回下一个数据时它才会计算。
`Iterator`甚至可以表示一个无限大的数据流，例如全体自然数。而使用list是永远不可能存储全体自然数的。

**Python的`for`循环本质上就是通过不断调用`next()`函数实现的，例如：**

```python
for x in [1, 2, 3, 4, 5]:
    pass
```

实际上完全等价于：
```python
# 首先获得Iterator对象:
it = iter([1, 2, 3, 4, 5])
# 循环:
while True:
    try:
        # 获得下一个值:
        x = next(it)
    except StopIteration:
        # 遇到StopIteration就退出循环
        break
```

#### map/reduce

**map()接收两个参数，一个是函数，一个是`Iterable`,map将传入的函数依次作用到序列的每个元素上，并将结果作为新的`Iterable`返回。**

```python
>>> def f(x):
...     return x * x
...
>>> r = map(f, [1, 2, 3, 4, 5, 6, 7, 8, 9])
>>> list(r)
[1, 4, 9, 16, 25, 36, 49, 64, 81]

# 一行代码将所有的数字转换为字符串
>>> list(map(str, [1, 2, 3, 4, 5, 6, 7, 8, 9]))
['1', '2', '3', '4', '5', '6', '7', '8', '9']
```

**`reduce`把一个函数作用在一个序列`[x1, x2, x3, ...]`上，这个函数必须接收两个参数，`reduce`把结果继续和序列的下一个元素做累积计算，其效果就是：**

```cpp
reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)
```

比方说对一个序列求和，就可以用`reduce`实现：
```python
>>> from functools import reduce
>>> def add(x, y):
...     return x + y
...
>>> reduce(add, [1, 3, 5, 7, 9])
25


>>> from functools import reduce
>>> def fn(x, y):
...     return x * 10 + y
...
>>> def char2num(s):
...     digits = {'0': 0, '1': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9}
...     return digits[s]
...
>>> reduce(fn, map(char2num, '13579'))
13579
```

#### filter

和map类似的，filter接收一个函数和一个序列。和`map()`不同的是，`filter()`把传入的函数依次作用于每个元素，然后根据返回值是`True`还是`False`决定保留还是丢弃该元素。
如: 一个list中,删掉偶数,只保留奇数:

```python
def is_odd(n):
    return n % 2 == 1

list(filter(is_odd, [1, 2, 4, 5, 6, 9, 10, 15]))
# 结果: [1, 5, 9, 15]
```

如: 把一个序列中的空字符串删掉，可以这么写
```python
def not_empty(s):
    return s and s.strip()

list(filter(not_empty, ['A', '', 'B', None, 'C', '  ']))
# 结果: ['A', 'B', 'C']
```

注意到`filter()`函数返回的是一个`Iterator`，也就是一个惰性序列，所以要强迫`filter()`完成计算结果，需要用`list()`函数获得所有结果并返回list。

#### sorted:排序

```python
>>> sorted([36, 5, -12, 9, -21], key=abs)
[5, 9, -12, -21, 36]

>>> sorted(['bob', 'about', 'Zoo', 'Credit'], key=str.lower, reverse=True)
['Zoo', 'Credit', 'bob', 'about']

#按照成绩倒序
>>> def by_score(t):
...     return -t[1]
... 
>>> L = [('Bob', 75), ('Adam', 92), ('Bart', 66), ('Lisa', 88)]
>>> sorted(L,key=by_score)
[('Adam', 92), ('Lisa', 88), ('Bob', 75), ('Bart', 66)]
```

#### 匿名函数lambda

**匿名函数有个限制，就是只能有一个表达式，不用写`return`，返回值就是该表达式的结果。**

```python
>>> list(map(lambda x: x * x, [1, 2, 3, 4, 5, 6, 7, 8, 9]))
[1, 4, 9, 16, 25, 36, 49, 64, 81]

# 可以把匿名函数赋值给一个变量，再利用变量来调用该函数
>>> f = lambda x: x * x
>>> f
<function <lambda> at 0x101c6ef28>
>>> f(5)
25
```

#### 模块

- 举个例子，一个`abc.py`的文件就是一个名字叫`abc`的模块，一个`xyz.py`的文件就是一个名字叫`xyz`的模块;

- 假设我们的`abc`和`xyz`这两个模块名字与其他模块冲突了，于是我们可以通过包来组织模块，避免冲突;

  ```
  mycompany
  ├─ __init__.py
  ├─ abc.py
  └─ xyz.py
  ```

  现在，`abc.py`模块的名字就变成了`mycompany.abc`，类似的，`xyz.py`的模块名变成了`mycompany.xyz`。

  **请注意，每一个包目录下面都会有一个`__init__.py`的文件，这个文件是必须存在的，否则，Python就把这个目录当成普通目录，而不是一个包。`__init__.py`可以是空文件，也可以有Python代码，因为`__init__.py`本身就是一个模块，而它的模块名就是`mycompany`。**

- 多级目录:

  ```
  mycompany
   ├─ web
   │  ├─ __init__.py
   │  ├─ utils.py
   │  └─ www.py
   ├─ __init__.py
   ├─ abc.py
   └─ utils.py
  ```

  文件`www.py`的模块名就是`mycompany.web.www`，两个文件`utils.py`的模块名分别是`mycompany.utils`和`mycompany.web.utils`。

- 导入已有模块，然后使用:

  ```python
  import sys
  
  def test():
      args = sys.argv
      if len(args)==1:
          print('Hello, world!')
      elif len(args)==2:
          print('Hello, %s!' % args[1])
      else:
          print('Too many arguments!')
  
  if __name__=='__main__':
      test()
  ```

  `sys`模块有一个`argv`变量，用list存储了命令行的所有参数。`argv`至少有一个元素，因为第一个参数永远是该.py文件的名称，例如：
  运行`python3 hello.py`获得的`sys.argv`就是`['hello.py']`；
  运行`python3 hello.py Michael`获得的`sys.argv`就是`['hello.py', 'Michael']`。
  最后两行代码:

  ```python
  if __name__=='__main__':
      test()
  ```

  当我们在命令行运行`hello`模块文件时，Python解释器把一个特殊变量`__name__`置为`__main__`，而如果在其他地方导入该`hello`模块时，`if`判断将失败，因此，这种`if`测试可以让一个模块通过命令行运行时执行一些额外的代码，最常见的就是运行测试。

  ```python
  $ python3 hello.py #命令行运行
  Hello, world!
  
  $ python3
  Python 3.4.3 (v3.4.3:9b73f1c3e601, Feb 23 2015, 02:52:03) 
  [GCC 4.2.1 (Apple Inc. build 5666) (dot 3)] on darwin
  Type "help", "copyright", "credits" or "license" for more information.
  >>> import hello # 导入时，没有打印Hello, word!，因为没有执行test()函数
  >>> hello.test()
  Hello, world!
  ```

- 作用域: 可见与不可见
  在一个模块中，我们可能会定义很多函数和变量，但有的函数和变量我们希望给别人使用，有的函数和变量我们希望仅仅在模块内部使用。在Python中，是通过`_`前缀来实现的。

  - 正常的函数和变量名是公开的（public），可以被直接引用，比如：`abc`，`x123`，`PI`等;
  - 类似`__xxx__`这样的变量是特殊变量，可以被直接引用，但是有特殊用途，比如上面的`__author__`，`__name__`就是特殊变量，`hello`模块定义的文档注释也可以用特殊变量`__doc__`访问，我们自己的变量一般不要用这种变量名;
  - 类似`_xxx`和`__xxx`这样的函数或变量就是非公开的（private），不应该被直接引用，比如`_abc`，`__abc`等。private函数和变量“不应该”被直接引用，而不是“不能”被直接引用，是因为Python并没有一种方法可以完全限制访问private函数或变量，但是，从编程习惯上不应该引用private函数或变量。

  ```python
  def _private_1(name):
      return 'Hello, %s' % name
  
  def _private_2(name):
      return 'Hi, %s' % name
  
  def greeting(name):
      if len(name) > 3:
          return _private_1(name)
      else:
          return _private_2(name)
  ```

- 安装第三方模块

  - `pip install Pillow`

- 模块搜索路径

  当我们试图加载一个模块时，Python会在指定的路径下搜索对应的.py文件，如果找不到，就会报错：

  ```python
  >>> import mymodule
  Traceback (most recent call last):
    File "<stdin>", line 1, in <module>
  ImportError: No module named mymodule
  ```

  默认情况下，Python解释器会搜索当前目录、所有已安装的内置模块和第三方模块，搜索路径存放在`sys`模块的`path`变量中：

  ```python
  >>> import sys
  >>> sys.path
  ['', '/usr/lib64/python36.zip', '/usr/lib64/python3.6', '/usr/lib64/python3.6/lib-dynload', '/usr/local/lib64/python3.6/site-packages', '/usr/local/lib/python3.6/site-packages', '/usr/lib64/python3.6/site-packages', '/usr/lib/python3.6/site-packages']
  ```

  如果我们要添加自己的搜索目录，有两种方法：

  - 直接修改`sys.path`，添加要搜索的目录

    ```python
    >>> import sys
    >>> sys.path.append('/Users/michael/my_py_scripts')
    ```

  - 第二种方法是设置环境变量`PYTHONPATH`，该环境变量的内容会被自动添加到模块搜索路径中。

#### 面向对象

```python
class Student(object):
    def __init__(self, name, score):
        self.name = name
        self.score = score

    def print_score(self):
        print('%s: %s' % (self.name, self.score))

bart = Student('Bart Simpson', 59)
lisa = Student('Lisa Simpson', 87)
bart.print_score()
lisa.print_score()
```

注意到`__init__`方法的第一个参数永远是`self`，表示创建的实例本身，因此，在`__init__`方法内部，就可以把各种属性绑定到`self`，因为`self`就指向创建的实例本身。
有了`__init__`方法，在创建实例的时候，就不能传入空的参数了，必须传入与`__init__`方法匹配的参数，但`self`不需要传，Python解释器自己会把实例变量传进去。

**访问限制**

上面的Student操作中，外部代码还是可以自由地修改一个实例的`name`、`score`属性:

```python
>>> bart = Student('Bart Simpson', 59)
>>> bart.score
59
>>> bart.score = 99
>>> bart.score
99
```

**如果要让内部属性不被外部访问，可以把属性的名称前加上两个下划线`__`，在Python中，实例的变量名如果以`__`开头，就变成了一个私有变量（private），只有内部可以访问**，外部不能访问，所以，我们把Student类改一改：

```python
class Student(object):

    def __init__(self, name, score):
        self.__name = name
        self.__score = score

    def print_score(self):
        print('%s: %s' % (self.__name, self.__score))
        
    def get_name(self): #添加方法让外部调用者获取值
        return self.__name

    def get_score(self):
        return self.__score

>>> bart = Student('Bart Simpson', 59)
>>> bart.__name
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
AttributeError: 'Student' object has no attribute '__name'
```

**继承和多态**

```python
class Animal(object):
    def run(self):
        print('Animal is running...')
class Cat(Animal):
    pass

class Dog(Animal):

    def run(self):
        print('Dog is running...')

    def eat(self):
        print('Eating meat...')
        
 def run_twice(animal): #多态性
    animal.run()
    animal.run()

>>> run_twice(Animal())
Animal is running...
Animal is running...

>>> run_twice(Dog())
Dog is running...
Dog is running...

# 判断对象的类型
a = list() # a是list类型
b = Animal() # b是Animal类型
c = Dog() # c是Dog类型

>>> isinstance(a, list)
True
>>> isinstance(b, Animal)
True
>>> isinstance(c, Dog)
True
>>> isinstance(c, Animal) #注意这里
True
```

#### 获取对象的信息

- `type()`:获取对象的类型

  ```python
  >>> type(123)
  <class 'int'>
  >>> type('str')
  <class 'str'>
  >>> type(None)
  <type(None) 'NoneType'>
  
  >>> type(123)==type(456)
  True
  >>> type(123)==int
  True
  >>> type('abc')==type('123')
  True
  >>> type('abc')==str
  True
  >>> type('abc')==type(123)
  False
  ```

- `isinstance()`判断对象类型

  ```python
  >>> a = Animal()
  >>> d = Dog()
  >>> h = Husky()
  >>> isinstance(d, Dog) and isinstance(d, Animal)
  True
  
  >>> isinstance('a', str)
  True
  >>> isinstance(123, int)
  True
  >>> isinstance(b'a', bytes)
  True
  ```

- `dir()`：获取对象的所有属性和方法

  ```python
  >>> dir('ABC')
  ['__add__', '__class__',..., '__subclasshook__', 'capitalize', 'casefold',..., 'zfill']
  ```

- `getattr()`、`setattr()`、`hasattr()`操作对象的状态

  ```python
  >>> class MyObject(object):
  ...     def __init__(self):
  ...         self.x = 9
  ...     def power(self):
  ...         return self.x * self.x
  ...
  >>> obj = MyObject()
  
  >>> hasattr(obj, 'x') # 有属性'x'吗？
  True
  >>> obj.x
  9
  >>> hasattr(obj, 'y') # 有属性'y'吗？
  False
  >>> setattr(obj, 'y', 19) # 设置一个属性'y'
  >>> hasattr(obj, 'y') # 有属性'y'吗？
  True
  >>> getattr(obj, 'y') # 获取属性'y'
  19
  >>> obj.y # 获取属性'y'
  19
  ```

- **使用@property**

  在绑定属性时，如果我们直接把属性暴露出去，虽然写起来很简单，但是，没办法检查参数，导致可以把成绩随便改:

  ```cpp
  s = Student()
  s.score = 9999
  ```

  这显然不合逻辑。为了限制score的范围，可以通过一个`set_score()`方法来设置成绩，再通过一个`get_score()`来获取成绩，这样，在`set_score()`方法里，就可以检查参数：

  ```cpp
  class Student(object):
  
      def get_score(self):
           return self._score
  
      def set_score(self, value):
          if not isinstance(value, int):
              raise ValueError('score must be an integer!')
          if value < 0 or value > 100:
              raise ValueError('score must between 0 ~ 100!')
          self._score = value
  ```

  但是，上面的调用方法又略显复杂，没有直接用属性这么直接简单。

  有没有既能检查参数，又可以用类似属性这样简单的方式来访问类的变量呢？

  还记得装饰器（decorator）可以给函数动态加上功能吗？对于类的方法，装饰器一样起作用。

  Python内置的`@property`装饰器就是负责把一个方法变成属性调用的：

  ```python
  class Student(object):
  
      @property
      def score(self):
          return self._score
  
      @score.setter
      def score(self, value):
          if not isinstance(value, int):
              raise ValueError('score must be an integer!')
          if value < 0 or value > 100:
              raise ValueError('score must between 0 ~ 100!')
          self._score = value
  ```

  `@property`的实现比较复杂，我们先考察如何使用。把一个getter方法变成属性，只需要加上`@property`就可以了，此时，`@property`本身又创建了另一个装饰器`@score.setter`，负责把一个setter方法变成属性赋值，于是，我们就拥有一个可控的属性操作：

  ```python
  class Student(object):
  
      @property
      def score(self):
          return self._score
  
      @score.setter
      def score(self, value):
          if not isinstance(value, int):
              raise ValueError('score must be an integer!')
          if value < 0 or value > 100:
              raise ValueError('score must between 0 ~ 100!')
          self._score = value
  
  >>> s = Student()
  >>> s.score = 60 # OK，实际转化为s.set_score(60)
  >>> s.score # OK，实际转化为s.get_score()
  60
  >>> s.score = 9999
  Traceback (most recent call last):
    ...
  ValueError: score must between 0 ~ 100!
  ```

  还可以定义只读属性，只定义getter方法，不定义setter方法就是一个只读属性：

  ```python
  class Student(object):
  
      @property
      def birth(self):
          return self._birth
  
      @birth.setter
      def birth(self, value):
          self._birth = value
  
      @property
      def age(self):
          return 2015 - self._birth
  ```

  上面的`birth`是可读写属性，而`age`就是一个*只读*属性，因为`age`可以根据`birth`和当前时间计算出来。

  要特别注意：**属性的方法名不要和实例变量重名。例如，以下的代码是错误的**

  ```python
  class Student(object):
      # 方法名称和实例变量均为birth:
      @property
      def birth(self):
          return self.birth
  ```

- **定制属性**

  - **`__str__`**用于打印:

    ```python
    >>> class Student(object):
    ...     def __init__(self, name):
    ...         self.name = name
    ...
    >>> print(Student('Michael'))
    <__main__.Student object at 0x109afb190>
    
    >>> class Student(object):
    ...     def __init__(self, name):
    ...         self.name = name
    ...     def __str__(self):
    ...         return 'Student object (name: %s)' % self.name
    ...
    >>> print(Student('Michael'))
    Student object (name: Michael)
    >>> s = Student('Michael')
    >>> s
    <__main__.Student object at 0x109afb310> #直接敲遍历不用print,打印出来的还是不好看
    ```

  - **`__repr__()`**返回程序开发者看到的字符串，用于调试服务

    ```python
    class Student(object):
        def __init__(self, name):
            self.name = name
        def __str__(self):
            return 'Student object (name=%s)' % self.name
        __repr__ = __str__ #偷懒写法
    >>> s = Student('Michael')
    >>> s
    Student object (name: Michael)
    ```

  - **`__iter__`**将这个类用于`for ... in`循环。类似`list`或`tuple`那样，就必须实现一个`__iter__()`方法，该方法返回一个迭代对象，然后，Python的for循环就会不断调用该迭代对象的`__next__()`方法拿到循环的下一个值，直到遇到`StopIteration`错误时退出循环。
    以斐波那契数列为例，写一个Fib类，可以作用于for循环:

    ```python
    class Fib(object):
        def __init__(self):
            self.a, self.b = 0, 1 # 初始化两个计数器a，b
    
        def __iter__(self):
            return self # 实例本身就是迭代对象，故返回自己
    
        def __next__(self):
            self.a, self.b = self.b, self.a + self.b # 计算下一个值
            if self.a > 100000: # 退出循环的条件
                raise StopIteration()
            return self.a # 返回下一个值
    ```

    现在，试试把Fib实例作用于for循环:

    ```python
    >>> for n in Fib():
    ...     print(n)
    ...
    1
    1
    2
    3
    5
    ...
    46368
    75025
    ```

  - **`__getitem__()`**要表现得像list那样按照下标取出元素，需要实现`__getitem__()`方法

    ```python
    class Fib(object):
        def __getitem__(self, n):
            a, b = 1, 1
            for x in range(n):
                a, b = b, a + b
            return a
     >>> f = Fib()
    >>> f[0]
    1
    >>> f[1]
    1
    >>> f[2]
    2
    >>> f[3]
    3
    >>> f[10]
    89
    >>> f[100]
    573147844013817084101
    ```

  - **`__call__()`**

    ```python
    class Student(object):
        def __init__(self, name):
            self.name = name
    
        def __call__(self):
            print('My name is %s.' % self.name)
    
    >>> s = Student('Michael')
    >>> s() # self参数不要传入
    My name is Michael.
    ```

  - **枚举类**:

    ```python
    from enum import Enum, unique
    
    @unique
    class Weekday(Enum):
        Sun = 0 # Sun的value被设定为0
        Mon = 1
        Tue = 2
        Wed = 3
        Thu = 4
        Fri = 5
        Sat = 6
    ```

    `@unique`装饰器可以帮助我们检查保证没有重复值。

#### 错误梳理

```python
try:
    print('try...')
    r = 10 / 0
    print('result:', r)
except ZeroDivisionError as e:
    print('except:', e)
finally:
    print('finally...')
print('END')


try:
    print('try...')
    r = 10 / int('2')
    print('result:', r)
except ValueError as e:
    print('ValueError:', e)
except ZeroDivisionError as e:
    print('ZeroDivisionError:', e)
else: # 在except语句块后面加一个else，当没有错误发生时，会自动执行else语句
    print('no error!')
finally:
    print('finally...')
print('END')
```

Python所有的错误都是从`BaseException`类派生的，常见的错误类型和继承关系看这里：
[https://docs.python.org/3/library/exceptions.html#exception-hierarchy](https://docs.python.org/3/library/exceptions.html#exception-hierarchy)

```python
def foo(s):
    return 10 / int(s)

def bar(s):
    return foo(s) * 2

def main():
    try:
        bar('0') #不需要在每个可能出错的地方去捕获错误，只要在合适的层次去捕获错误就可以了
    except Exception as e:
        print('Error:', e)
    finally:
        print('finally...')
```

**记录错误**

如果不捕获错误，自然可以让Python解释器来打印出错误堆栈，但程序也被结束了。既然我们能捕获错误，就可以把错误堆栈打印出来，然后分析错误原因，同时，让程序继续执行下去。

Python内置的`logging`模块可以非常容易地记录错误信息:

```python
# err_logging.py

import logging

def foo(s):
    return 10 / int(s)

def bar(s):
    return foo(s) * 2

def main():
    try:
        bar('0')
    except Exception as e:
        logging.exception(e)
main()
print('END')
```

**抛出错误**

```python
# err_raise.py
class FooError(ValueError):
    pass

def foo(s):
    n = int(s)
    if n==0:
        raise FooError('invalid value: %s' % s)
    return 10 / n

foo('0')
```

另一种错误处理的方式:

```python
# err_reraise.py

def foo(s):
    n = int(s)
    if n==0:
        raise ValueError('invalid value: %s' % s)
    return 10 / n
def bar():
    try:
        foo('0')
    except ValueError as e:
        print('ValueError!')
        raise #问题继续朝上抛出
bar()
```

在`bar()`函数中，我们明明已经捕获了错误，但是，打印一个`ValueError!`后，又把错误通过`raise`语句抛出去了，这不有病么？
**其实这种错误处理方式不但没病，而且相当常见。捕获错误目的只是记录一下，便于后续追踪。但是，由于当前函数不知道应该怎么处理该错误，所以，最恰当的方式是继续往上抛，让顶层调用者去处理。好比一个员工处理不了一个问题时，就把问题抛给他的老板，如果他的老板也处理不了，就一直往上抛，最终会抛给CEO去处理。**

`raise`语句如果不带参数，就会把当前错误原样抛出。此外，在`except`中`raise`一个Error，还可以把一种类型的错误转化成另一种类型：

```python
try:
    10 / 0
except ZeroDivisionError:
    raise ValueError('input error!')
```

#### IO编程

```python
>>> f = open('/Users/michael/test.txt', 'r')
```

如果文件不存在，`open()`函数就会抛出一个`IOError`的错误，并且给出错误码和详细的信息告诉你文件不存在:
```python
>>> f=open('/Users/michael/notfound.txt', 'r')
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
FileNotFoundError: [Errno 2] No such file or directory: '/Users/michael/notfound.txt'
```

如果文件打开成功，接下来，调用`read()`方法可以一次读取文件的全部内容，Python把内容读到内存，用一个`str`对象表示:
```python
>>> f.read()
'Hello, world!'
>>> f.close()
```

由于文件读写时都有可能产生`IOError`，一旦出错，后面的`f.close()`就不会调用。所以，为了保证无论是否出错都能正确地关闭文件，我们可以使用`try ... finally`来实现:

```python
try:
    f = open('/path/to/file', 'r')
    print(f.read())
finally:
    if f:
        f.close()
```

`read()`会一次性读取文件的全部内容，如果文件有10G，内存就爆了，所以，要保险起见，可以**反复调用`read(size)`方法，每次最多读取size个字节的内容。调用`readline()`可以每次读取一行内容，调用`readlines()`一次读取所有内容并按行返回`list`。**

```python
for line in f.readlines():
    print(line.strip()) # 把末尾的'\n'删掉
```

**二进制文件**

前面讲的默认都是读取文本文件，并且是UTF-8编码的文本文件。要读取二进制文件，比如图片、视频等等，**用`'rb'`模式打开文件即可**：

```python
>>> f = open('/Users/michael/test.jpg', 'rb')
>>> f.read()
b'\xff\xd8\xff\xe1\x00\x18Exif\x00\x00...' # 十六进制表示的字节
```

**写文件**

```python
>>> f = open('/Users/michael/test.txt', 'w')
>>> f.write('Hello, world!')
>>> f.close()
```

**StringIO**

很多时候，数据读写不一定是文件，也可以在内存中读写。

```python
>>> from io import StringIO
>>> f = StringIO()
>>> f.write('hello')
5
>>> f.write(' ')
1
>>> f.write('world!')
6
>>> print(f.getvalue())
hello world!
```

要读取StringIO，可以用一个str初始化StringIO，然后，像读文件一样读取:

```python
>>> from io import StringIO
>>> f = StringIO('Hello!\nHi!\nGoodbye!')
>>> while True:
...     s = f.readline()
...     if s == '':
...         break
...     print(s.strip())
...
Hello!
Hi!
Goodbye!
```

**BytesIO**

BytesIO实现了在内存中读写bytes，我们创建一个BytesIO，然后写入一些bytes:

```python
>>> from io import BytesIO
>>> f = BytesIO()
>>> f.write('中文'.encode('utf-8'))
6
>>> print(f.getvalue())
b'\xe4\xb8\xad\xe6\x96\x87'
```

请注意，写入的不是str，而是经过UTF-8编码的bytes。
和StringIO类似，可以用一个bytes初始化BytesIO，然后，像读文件一样读取:

```python
>>> from io import BytesIO
>>> f = BytesIO(b'\xe4\xb8\xad\xe6\x96\x87')
>>> f.read()
b'\xe4\xb8\xad\xe6\x96\x87'
```

#### 序列化

**json**

Python内置的`json`模块提供了非常完善的Python对象到JSON格式的转换。我们先看看如何把Python对象变成一个JSON：

```python
>>> import json
>>> d = dict(name='Bob', age=20, score=88)
>>> json.dumps(d)
'{"age": 20, "score": 88, "name": "Bob"}'

>>> json_str = '{"age": 20, "score": 88, "name": "Bob"}'
>>> json.loads(json_str)
{'age': 20, 'score': 88, 'name': 'Bob'}
```

**json进阶**

```python
import json

class Student(object):
    def __init__(self, name, age, score):
        self.name = name
        self.age = age
        self.score = score

s = Student('Bob', 20, 88)
print(json.dumps(s))
Traceback (most recent call last):
  ...
TypeError: <__main__.Student object at 0x10603cc50> is not JSON serializable


def student2dict(std):
    return {
        'name': std.name,
        'age': std.age,
        'score': std.score
    }
>>> print(json.dumps(s, default=student2dict))
{"age": 20, "name": "Bob", "score": 88}

def dict2student(d):
    return Student(d['name'], d['age'], d['score'])
    
>>> json_str = '{"age": 20, "score": 88, "name": "Bob"}'
>>> print(json.loads(json_str, object_hook=dict2student))
<__main__.Student object at 0x10cd3c190>
```

