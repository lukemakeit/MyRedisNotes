## 内存逃逸

参考文章:

- [golang 逃逸分析详解](https://zhuanlan.zhihu.com/p/91559562)
- [再不Go就来不及了！Go高性能编程技法解读](https://mp.weixin.qq.com/s/fXKSr8GXaYxG1WCrLIgneg)

一个局部变量以指针的方式传递给其他函数，变量就会逃逸到堆上？？
如java代码，简单来说JVM的逃逸分析会在运行时检测当前方法栈帧内new出来的对象的引用是否被传出当前栈帧，传出则发生逃逸，未传出则未发生逃逸。

```java
public void test(){
    List<Integer> a = new ArrayList<>();
    a.add(1); // a 未发生逃逸，因此在栈上分配
}

public List<Integer> test1(){
    List<Integer> a = new ArrayList<>();
    a.add(1);
    return a  //a 发生逃逸，因此分配在堆上
}
```

对于未发生逃逸的变量，则直接在栈上分配内存。因为栈上内存由在函数返回时自动回收，因此能减小gc压力。
在C语言中，可以使用`malloc`、`free`手动在堆上分配和回收内存。
**Go语言中，堆内存是通过垃圾回收机制自动管理的，无需开发者指定。那么，Go编译器怎么知道某个变量需要分配在栈上，还是堆上？**
**编译器决定内存分配位置的方式，就称为逃逸分析(escape analysis)。逃逸分析有编译器完成，作用于编译阶段。**

一般逃逸发生在如下几种情况:

- 变量较大(栈空间不足)
- 变量大小不确定(如slice长度和容量不定)
- 返回地址
- 返回引用(引用变量的底层是指针)
- 被指针类型的slice、map和chan引用的指针，也会发生逃逸
- 返回值类型不确定(不能确定大小)
- 闭包

知道变量逃逸的原因后，我们可以有意识地控制变量不发生逃逸，将其控制在栈上，减少堆变量的分配，降低GC成本，提高程序性能。

- **<mark style="color:blue">局部切片尽可能确定长度或容量</mark>**

  使用局部的切片时，已知切片的长度或容量，请使用常量或数值字面量来定义。

  ```go
  func main() {
    number := 10
    s1 := make([]int, 0, number) //逃逸
    for i := 0; i < number; i++ {
      s1 = append(s1, i)
    }
    s2 := make([]int, 0, 10) //不逃逸
    for i := 0; i < 10; i++ {
      s2 = append(s2, i)
    }
  }
  ```

- **<mark style="color:blue">返回值VS返回指针</mark>**

  传指针可以减少值的拷贝，但是会导致内存分配逃逸到堆中，增加垃圾回收（GC）的负担。在对象频繁创建和删除的场景下，返回指针导致的GC开销可能会严重影响性能。
  **一般情况下，对于需要修改原对象，或占用内存比较大的对象，返回指针。对于只读或占用内存较小的对象，返回值能够获得更好的性能。**

- **<mark style="color:blue">返回值使用确定类型</mark>**

  如果变量类型不确定，那么将会逃逸到堆上。所以，函数返回值如果能确定的类型，就不要使用interface{}。

- 