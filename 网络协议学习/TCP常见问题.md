## TCP/IP 场景问题

本文内容，基本全来来自于 <mark style="color:red">**公众号 "小林coding"**</mark>

### TCP

![image-20220221151508855](https://my-typora-pictures-1252258460.cos.ap-guangzhou.myqcloud.com/img/image-20220221151508855.png)

**序列号**：在建⽴连接时由**计算机⽣成的随机数作为其初始值**,通过 **SYN包**传给接收端主机,每发送⼀次数据，就**累加**⼀次该**数据字节数**的⼤⼩。⽤来解决⽹络包乱序问题。例如序号为 301，表示第一个字节的编号为 301，如果携带的数据长度为 100 字节，那么下一个报文段的序号应为 401;

**确认应答号**：指下⼀次**期望**收到的数据的序列号,发送端收到这个确认应答以后可以认为**在这个序号以前的数 据都已经被正常接收**。⽤来解决不丢包的问题。例如 B 正确收到A发送来的一个报文段,序号为 501,携带的数据长度为 200 字节，因此 B 期望下一个报文段的序号为 701，B发送给A 的确认答应号就为 701。

**首部长度/数据偏移:**指的是数据部分距离报文段起始处的偏移量，实际上指的是首部的长度。注意: **首部长度的以32位为长度单位，也就是4字节。因此TCP首部的最大长度是60字节。即2^4-1=15,15*32位=15\*4字节=60字节。**

**控制位：**八位从左到右分别是 CWR,ECE,URG,ACK,PSH,RST,SYN,FIN

- **URG(URGent)：**该位设为 1，表示包中有需要紧急处理的数据，对于需要紧急处理的数据，与后面的紧急指针有关;
- **ACK(ACKnowlegment)：**该位设为 1，**确认应答的字段有效,TCP规定除了最初建立连接时的 SYN 包之外该位必须设为 1**；
- **PSH(PuSH)**:该位设为 1，表示需要将收到的数据立刻传给上层应用协议，若设为 0，则先将数据进行缓存;
- **RST(ReSeT)**:该位设为 1，表示 TCP 连接出现异常必须强制断开连接；
- **SYN(SYNchronization)**：用于建立连接，该位设为 1，表示希望建立连接，并在其序列号的字段进行序列号初值设定；
- **FIN(FINish)**:该位设为 1，表示今后不再有数据发送，希望断开连接。当通信结束希望断开连接时，通信双方的主机之间就可以相互交换 FIN 位置为 1 的 TCP 段。

#### 问题一: 为什么需要 TCP 协议？ TCP ⼯作在哪⼀层？

<img src="https://my-typora-pictures-1252258460.cos.ap-guangzhou.myqcloud.com/img/image-20220221155116611.png" alt="image-20220221155116611" style="zoom:33%;" />

IP 层是**不可靠**的,它**不保证⽹络包的交付、不保证⽹络包的按序交付、也不保证⽹络包中的数据的完整性**。

如果需要保障⽹络数据包的可靠性，那么就需要由**上层(传输层)的 TCP 协议来负责**。

因为TCP是⼀个⼯作**在传输层的可靠数据传输的服务,它能确保接收端接收的⽹络包是⽆损坏、⽆间隔、⾮冗余 和按序的**。

#### 问题二: 什么TCP？

TCP 是**⾯向连接的**、**可靠的**、**基于字节流的**传输层通信协议。

- **面向连接的**: ⼀定是**⼀对⼀**才能连接，不能像 UDP 协议可以⼀个主机同时向多个主机发送消息，也就是⼀ 对多是⽆法做到的；
- **可靠的**: ⽆论的⽹络链路中出现了怎样的链路变化，TCP 都可以保证⼀个报⽂⼀定能够到达接收端;
- **基于字节流的**: 消息是**没有边界**的, 所以⽆论我们消息有多⼤都可以进⾏传输。并且消息是**有序的**，当 **前⼀个**消息没有收到的时候，即使它先收到了后⾯的字节，那么也不能扔给应⽤层去处理，同时对**重复**的报⽂会⾃动丢弃。

#### 问题三: 如何唯⼀确定⼀个 TCP 连接呢？

TCP 四元组可以唯⼀的确定⼀个连接，四元组包括如下：

- 源地址
- 源端口
- 目的地址
- 目的端口

**源地址和⽬的地址的字段(32位)是在 IP 头部中，作⽤是通过 IP 协议发送报⽂给对⽅主机**

**源端⼝和⽬的端⼝的字段(16位)是在 TCP 头部中，作⽤是告诉 TCP 协议应该把报⽂发给哪个进程**

<img src="https://my-typora-pictures-1252258460.cos.ap-guangzhou.myqcloud.com/img/image-20220221161346504.png" alt="image-20220221161346504" style="zoom: 33%;" />

#### 问题四: 有⼀个 IP 的服务器监听了⼀个端⼝，它的 TCP 的最⼤连接数是多少？

服务端最⼤并发 TCP 连接数通常受两个限制:

- ⾸先主要是**⽂件描述符限制(单个进程可打开的文件数)**，Socket 都是⽂件，所以⾸先要通过`ulimit`配置⽂件描述符的数⽬;
- 另⼀个是**内存限制**,每个 TCP 连接都要占⽤⼀定内存，操作系统的内存是有限的。

#### 问题四: UDP 和 TCP 有什么区别呢？分别的应⽤场景是？

UDP 不提供复杂的控制机制，利⽤ IP 提供⾯向「⽆连接」的通信服务。

UDP 协议⾮常简单，头部只有 8 个字节(64 位)，UDP 的头部格式如下:

<img src="https://my-typora-pictures-1252258460.cos.ap-guangzhou.myqcloud.com/img/image-20220221162122406.png" alt="image-20220221162122406" style="zoom:50%;" />

- ⽬标和源端⼝：主要是告诉 UDP 协议应该把报⽂发给哪个进程;
- 包⻓度：该字段保存了**UDP⾸部的⻓度跟数据的⻓度**之和;
- 校验和：校验和是为了**提供可靠的 UDP ⾸部和数据⽽设计**;

TCP和UDP的区别:

1. 连接
   - TCP 是⾯向连接的传输层协议，传输数据前先要建⽴连接;
   - UDP 是不需要连接，即刻传输数据
2. 服务对象
   - TCP 是⼀对⼀的两点服务，即⼀条连接只有两个端点;
   - UDP ⽀持⼀对⼀、⼀对多、多对多的交互通信;
3. 可靠性
   - TCP 是可靠交付数据的，数据可以⽆差错、不丢失、不重复、按需到达;
   - UDP 是尽最⼤努⼒交付，不保证可靠交付数据;
4. 拥塞控制、流量控制
   - TCP 有拥塞控制和流量控制机制，保证数据传输的安全性;
   - UDP 则没有，即使⽹络⾮常拥堵了，也不会影响 UDP 的发送速率;
5. 首部开销
   - TCP ⾸部⻓度较⻓，会有⼀定的开销，⾸部在没有使用**选项**字段时是 20 个字节,如果使⽤了**选项**字段则会变⻓的;
   - UDP ⾸部只有 8 个字节，并且是固定不变的，开销较⼩;
6. 传输方式:
   - TCP 是流式传输，没有边界，但保证顺序和可靠;
   - UDP 是⼀个包⼀个包的发送，是有边界的，但可能会丢包和乱序;
7. 分⽚不同
   - TCP 的数据⼤⼩**如果⼤于 MSS ⼤⼩**，则会在**传输层进⾏分⽚**,**⽬标主机收到后,也同样在传输层组装 TCP 数据包，如果中途丢失了⼀个分⽚，只需要传输丢失的这个分⽚;**
   - UDP 的数据⼤⼩如果⼤于 MTU ⼤⼩，则会**在 IP 层进⾏分⽚，⽬标主机收到后，在 IP 层组装完数据**，接着再传给传输层，但是如果中途丢了⼀个分⽚，在实现可靠传输的 UDP 时则就需要重传所有的数据包，这样 传输效率⾮常差，**所以通常 UDP 的报⽂应该⼩于 MTU**;

**TCP和UDP的应用场景**

由于 TCP 是⾯向连接，能保证数据的可靠性交付，因此经常⽤于

- FTP文件传输;
- `HTTP`/`HTTPS`

由于 UDP ⾯向⽆连接，它可以随时发送数据，再加上UDP本身的处理既简单⼜⾼效，因此经常⽤于:

- 包总量较少的通信，如 `DNS `、 `SNMP`等;
- 视频、⾳频等多媒体通信;
- ⼴播通信;

**为什么UDP头部没有 首部长度/数据偏移 字段, 而TCP头部有 首部长度/数据偏移 字段？**

原因是 TCP 有可变⻓的**选项**字段，⽽ UDP 头部⻓度则是不会变化的，⽆需多⼀个字段去记录 UDP 的⾸部⻓度。

**为什么 UDP 头部有 包⻓度 字段，⽽ TCP 头部则没有 包⻓度 字段呢？**

TCP计算包数据长度的方式:

<mark style="color:red">**TCP数据的长度=IP总长度-IP首部长度-TCP首部长度**</mark>

**其中 IP 总⻓度 和 IP ⾸部⻓度，在 IP ⾸部格式是已知的。TCP ⾸部⻓度，则是在 TCP ⾸部格式已知的，所以就 可以求得 TCP 数据的⻓度。**

⼤家这时就奇怪了问：“ UDP 也是基于 IP 层的呀，那 UDP 的数据⻓度也可以通过这个公式计算呀？ 为何还要有包长度呢？”

这么⼀问，确实感觉 UDP 包⻓度 是冗余的。

**因为为了⽹络设备硬件设计和处理⽅便，⾸部⻓度需要是 4 字节的整数倍**。

#### TCP的三次握手

TCP 是⾯向连接的协议，所以使⽤ TCP 前必须先建⽴连接，⽽**建⽴连接是通过三次握⼿来进⾏的**。

1. 一开始，服务器端主动监听某个端口，处于 `LISTEN`状态

2. **三次握手的第一个报文: `SYN`报文**

   <img src="https://my-typora-pictures-1252258460.cos.ap-guangzhou.myqcloud.com/img/image-20220221213209167.png" alt="image-20220221213209167" style="zoom:50%;" />

   - 客户端会随机初始化序号(`client_isn`),将此序号置于`TCP`⾸部的**序号**字段中，同时把`SYN`标志位置为1,表示`SYN`报⽂;
   - 接着把第⼀个SYN报⽂发送给服务端，表示向服务端发起连接，**该报⽂不包含应⽤层数据，之后客户端处于`SYN-SENT`状态**。

3. **三次握手的第二个报文: `SYNC`+`ACK`报文**

   <img src="https://my-typora-pictures-1252258460.cos.ap-guangzhou.myqcloud.com/img/image-20220221214213700.png" alt="image-20220221214213700" style="zoom:50%;" />

   - 服务端收到客户端的`SYN`报⽂后，⾸先服务端也随机初始化⾃⼰的序号(`server_isn`)，将此序号填⼊TCP ⾸部的 **序号** 字段中;
   - 其次把TCP⾸部的 **确认应答号** 字段填⼊ `client_isn + 1`, 接着把`SYN`和`ACK`标志位置为 1 。
   - 最后把该报⽂发给客户端，该报⽂也不包含应⽤层数据，之后服务端处于`SYNRCVD`状态。

4. **三次握手的第三个报文: ACK 报文**

   <img src="https://my-typora-pictures-1252258460.cos.ap-guangzhou.myqcloud.com/img/image-20220221214749906.png" alt="image-20220221214749906" style="zoom:50%;" />

   - 客户端收到服务端报⽂后,还要向服务端回应最后⼀个应答报⽂,⾸先该应答报⽂`TCP`⾸部`ACK`标志位置为1;
   - 其次**确认应答号**字段填⼊`server_isn + 1`,<mark style="color:red">**最后把报⽂发送给服务端,这次报⽂可以携带客户到服务器的数据,之后客户端处于`ESTABLISHED`状态**</mark>。
   - 服务器收到客户端的应答报⽂后，也进⼊`ESTABLISHED状态;

   从上⾯的过程可以发现<mark style="color:red">**第三次握⼿是可以携带数据的，前两次握⼿是不可以携带数据的**</mark>，这也是⾯试常问的题。

   <img src="https://my-typora-pictures-1252258460.cos.ap-guangzhou.myqcloud.com/img/image-20220221233008417.png" alt="image-20220221233008417" style="zoom:50%;" />

   #### 问题四: 如何在Linux系统中查看TCP的状态？

   通过命令`netstat -ntap`命令查看。

   ![image-20220221215848388](https://my-typora-pictures-1252258460.cos.ap-guangzhou.myqcloud.com/img/image-20220221215848388.png)

   #### 问题五: 为什么是三次握手？不是2次、4次？

   - **原因一: 确认双方的收发能力**

     a. 第一次握手：客户端发送网络包，服务端收到了。这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的;
     b. 第二次握手：服务端发包，客户端收到了。这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常;
     c. 第三次握手：客户端发包，服务端收到了。这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常;
     所以，只有三次握手才能确认双方的接收与发送能力是否正常。

   - **原因二:三次握手才可以阻止 重复历史连接初始化  造成混乱**

     > The principle reason for the three-way handshake is to prevent old duplicate connection initiations from causing confusion

     <img src="https://my-typora-pictures-1252258460.cos.ap-guangzhou.myqcloud.com/img/image-20220221230112137.png" alt="image-20220221230112137" style="zoom:50%;" />

     这种场景中正确的处理方式

     <img src="https://my-typora-pictures-1252258460.cos.ap-guangzhou.myqcloud.com/img/image-20220221233229317.png" alt="image-20220221233229317" style="zoom:50%;" />

     客户端由于某种原因发送了两个不同序号的SYN包,网络环境是复杂的，旧的数据包有可能先到达服务器。如果是两次握手，服务器收到旧的 SYN 就会立刻建立连接，那么会造成网络异常。
     如果是三次握手，服务器需要回复 SYN+ACK包,客户端会对比ACK的序号，如果发现是旧的报文，就会给服务器发 RST 报文，直到正常的 SYN 到达服务器后才正常建立连接。
   
     所以三次握手才有足够的上下文信息来判断当前连接是否是历史连接。

   - **原因三: 同步双⽅初始序列号**

     TCP 协议的通信双⽅,都必须维护⼀个**序列号**,序列号是可靠传输的⼀个关键因素,它的作⽤:
     - 接收⽅可以去除重复的数据;
     - 接收⽅可以根据数据包的序列号按序接收;
     - 可以标识发送出去的数据包中， 哪些是已经被对⽅收到的;
   
     序列号在TCP连接中占据着⾮常重要的作⽤,所以当客户端发送携带 **初始序列号**的 SYN 报⽂的时候，需要服务端回⼀个`ACK`应答报⽂，表示客户端的 SYN 报⽂已被服务端成功接收，那当服务端发送 **初始序列号** 给客户端的时候,依然也要得到客户端的应答回应,这样⼀来⼀回,才能确保双⽅的初始序列号能被可靠的同步。

     <img src="https://my-typora-pictures-1252258460.cos.ap-guangzhou.myqcloud.com/img/image-20220221234540416.png" alt="image-20220221234540416" style="zoom:50%;" />

#### ISN 是什么？

答：ISN 全称是`Initial Sequence Number`，是TCP发送方的字节数据编号的原点，告诉对方我要开始发送数据的初始化序列号

#### **ISN 是固定不变的吗？**

答：ISN 如果是固定的，攻击者很容易猜出后续的确认序号，为了安全起见，避免被第三方猜到从而发送伪造的 `RST` 报文，因此 ISN 是动态生成的。

#### 问题六: 既然 IP 层会分⽚，为什么 TCP 层还需要 MSS 呢？

- <mark style="color:red">**`MTU`:一个网络包的最大长度，以太网中一般是`1500`字节;**</mark>
- <mark style="color:red">**`MSS`:除去IP和TCP头部之后，一个网络包所容纳的TCP数据的最大长度;**</mark>

<img src="https://my-typora-pictures-1252258460.cos.ap-guangzhou.myqcloud.com/img/image-20220221235752486.png" alt="image-20220221235752486" style="zoom:50%;" />



#### 问题七: 如果在TCP的整个报文(头部+数据)交给IP层进行分片，会有什么异常?

- 当IP层有⼀个超过MTU⼤⼩的数据(TCP头部+TCP数据)要发送,那么IP层就要进⾏分⽚,把数据分⽚成若⼲⽚,保证每⼀个分⽚都⼩于MTU。
- 把⼀份IP数据报进⾏分⽚以后,由⽬标主机的IP层来进⾏重新组装后，再交给上⼀层TCP传输层;
- 这看起来井然有序，**但这存在隐患的,那么当如果⼀个IP分⽚丢失，整个IP报⽂的所有分⽚都得重传**。
- **因为IP层本身没有超时重传机制,它由传输层的TCP来负责超时和重传。当接收⽅发现TCP报⽂(头部+数据)的某⼀⽚丢失后,则不会响应ACK给对⽅。**
- 那么发送⽅的 TCP 在超时后，就会重发 整个TCP报⽂(头部+数据)。

因此,可以得知由IP层进⾏分⽚传输，是⾮常没有效率的。
所以,**为了达到最佳的传输效能TCP协议在建⽴连接的时候通常要协商双⽅的MSS值,当TCP层发现数据超过MSS时，则就先会进⾏分⽚，当然由它形成的 IP 包的⻓度也就不会⼤于MTU，⾃然也就不⽤IP分⽚了**。

![image-20220222001439399](https://my-typora-pictures-1252258460.cos.ap-guangzhou.myqcloud.com/img/image-20220222001439399.png)

**经过TCP层分⽚后,如果⼀个TCP分⽚丢失后,进⾏重发时也是以MSS为单位,⽽不⽤重传所有的分⽚,⼤⼤增加了重传的效率。**

#### 问题八: 什么是SYN攻击？如何避免SYN攻击？

我们都知道TCP连接建⽴是需要三次握⼿,假设攻击者短时间伪造不同IP地址的`SYN`报⽂,服务端每接收到⼀个`SYN`报⽂,就进⼊`SYN_RCVD` 状态,但服务端发送出去的`ACK+SYN`报⽂，⽆法得到未知IP主机的`ACK`应答,久⽽久之就会占满服务端的`SYN` 接收队列（未连接队列） ，使得服务器不能为正常⽤户服务。

**避免SYN攻击方式一**

通过修改 Linux 内核参数，控制队列⼤⼩和当队列满时应做什么处理:
- net.core.netdev_max_backlog
当⽹卡接收数据包的速度⼤于内核处理的速度时，会有⼀个队列保存这些数据包。控制该队列的最⼤值。
- net.ipv4.tcp_max_syn_backlog
SYN_RCVD 状态连接的最⼤个数;
- net.ipv4.tcp_abort_on_overflow
超出处理能时，对新的 SYN 直接回报 RST，丢弃连接;

**避免SYN攻击的方式二**

Linux 内核的SYN(未完成连接建⽴)队列与Accpet(已完成连接建⽴)队列是如何⼯作的？

<img src="https://my-typora-pictures-1252258460.cos.ap-guangzhou.myqcloud.com/img/image-20220222002744557.png" alt="image-20220222002744557" style="zoom:50%;" />

正常流程:

- 当服务端接收到客户端的 SYN 报⽂时，会将其加⼊到内核的`SYN队列`；
- 接着发送`SYN + ACK`给客户端，等待客户端回应`ACK`报⽂;
- 服务端接收到`ACK报⽂`后，从`SYN 队列`移除放⼊到`Accept 队列`；
- 应⽤通过调⽤`accpet()socket接⼝，从`Accept 队列`取出连接

<img src="https://my-typora-pictures-1252258460.cos.ap-guangzhou.myqcloud.com/img/image-20220222002844178.png" alt="image-20220222002844178" style="zoom:50%;" />

如果不断受到SYN攻击，就会导致`SYN队列`被占满。`tcp_syncookies`的⽅式可以应对SYN攻击的⽅法:
`net.ipv4.tcp_syncookies = 1`

- 当`SYN队列`满之后,后续服务器收到`SYN包`,不进⼊`SYN 队列`；
- 计算出⼀个cookie值，再以`SYN+ACK`中的`序列号`返回客户端，服务端接收到客户端的应答报⽂时，服务器会检查这个`ACK 包的合法性。如果合法,直接放⼊到`Accept队列`。
- 最后应⽤通过调⽤`accpet()` socket 接⼝，从`Accept 队列`取出的连接

<img src="https://my-typora-pictures-1252258460.cos.ap-guangzhou.myqcloud.com/img/image-20220222003241241.png" alt="image-20220222003241241" style="zoom:50%;" />

#### TCP连接断开: 四次挥手过程和状态变迁

![image-20220222101753850](https://my-typora-pictures-1252258460.cos.ap-guangzhou.myqcloud.com/img/image-20220222101753850.png)

- 客户端打算关闭连接,此时会发送⼀个TCP⾸部`FIN`标志位被置为1的报⽂，也即`FIN`报⽂,之后客户端进⼊`FIN_WAIT_1`状态;
- 服务端收到该报⽂后，就向客户端发送`ACK`应答报⽂，接着服务端进⼊`CLOSED_WAIT`状态;
- 客户端收到服务端的`ACK`应答报⽂后，之后进⼊`FIN_WAIT_2`状态;
- **等待服务端处理完数据后**,也向客户端发送`FIN`报⽂，之后服务端进⼊`LAST_ACK`状态;
- 客户端收到服务端的`FIN`报⽂后，回⼀个`ACK`应答报⽂，之后进⼊`TIME_WAIT`状态;
- 服务器收到了`ACK`应答报⽂后，就进⼊了`CLOSED`状态,⾄此服务端已经完成连接的关闭;
- 客户端在经过`2MSL`⼀段时间后，⾃动进⼊`CLOSED`状态，⾄此客户端也完成连接的关闭;

你可以看到，每个⽅向都需要⼀个FIN和⼀个ACK，因此通常被称为**四次挥⼿**。

有⼀点需要注意是:<mark style="color:red">**主动关闭连接的，才有TIME_WAIT状态**</mark>。

#### 问题九: 为什么挥手需要四次?

再来回顾下四次挥⼿双⽅发`FIN`包的过程，就能理解为什么需要四次了。
- **关闭连接时，客户端向服务端发送FIN时,仅仅表示客户端不再发送数据了但是还能接收数据**。
- 服务器收到客户端的`FIN`报⽂时,**先回⼀个ACK应答报⽂,⽽服务端可能还有数据需要处理和发送,等服务端不再发送数据时,才发送 FIN 报⽂给客户端来表示同意现在关闭连接**。

从上⾯过程可知,**服务端通常需要等待完成数据的发送和处理，所以服务端的 ACK 和 FIN ⼀般都会分开发送，从⽽⽐三次握⼿导致多了⼀次**。

#### 问题十: 为什么TIME_WAIT等待的时间是2MSL？

- `MSL`是`Maximum Segment Lifetime`,报⽂最⼤⽣存时间,是任何报⽂在⽹络上存在的最⻓时间,超过这个时间报⽂将被丢弃。
- 因为TCP报⽂基于是IP协议的,⽽IP头中有⼀个TTL字段,是IP数据报可以经过的最⼤路由数,每经过⼀个处理他的路由器此值就减 1，当此值为 0 则数据报将被丢弃，同时发送ICMP报⽂通知源主机。
- `MSL`与`TTL`的区别:`MSL`的单位是时间,⽽`TTL`是经过路由跳数。所以`MSL`应该要⼤于等于`TTL`消耗为0的时间，以确保报⽂已被⾃然消亡。
- `TIME_WAIT`等待`2`倍的`MSL`,⽐较合理的解释是:⽹络中可能存在来⾃发送⽅的数据包,当这些发送⽅的数据包被接收⽅处理后⼜会向对⽅发送响应，所以⼀来⼀回需要等待 2 倍的时间。
- **`2MSL`的时间是从客户端接收到`FIN`后发送`ACK`开始计时的。如果在`TIME-WAIT`时间内,因为客户端的`ACK`没有传输到服务端，客户端⼜接收到了服务端重发的`FIN`报⽂，那么`2MSL`时间将重新计时**。
- 在`Linux`系统⾥`2MSL`默认是`60`秒，那么⼀个`MSL`也就是30秒。 Linux系统停留在 TIME_WAIT 的时间为固定的 60 秒

#### 问题十一: 为什么需要 TIME_WAIT 状态？

主动发起关闭连接的⼀⽅，才会有 TIME-WAIT 状态。

需要 TIME-WAIT 状态，主要是两个原因：

- 防⽌具有相同**四元组**的**旧**数据包被收到；

- 保证**被动关闭连接**的⼀⽅能被正确的关闭，即保证最后的`ACK`能让被动关闭⽅接收，从⽽帮助其正常关闭；

原因一: 防止旧连接的数据包**

假设 TIME-WAIT 没有等待时间或时间过短，被延迟的数据包抵达后会发⽣什么呢？

![image-20220222112510315](https://my-typora-pictures-1252258460.cos.ap-guangzhou.myqcloud.com/img/image-20220222112510315.png)

有相同端⼝的 TCP 连接被复⽤后，被延迟的 SEQ = 301 抵达了客户端，那么客户端是有可能正常接收这个过期的报⽂，这就会产⽣数据错乱等严重的问题。
所以,TCP就设计出了这么⼀个机制,<mark style="color:blue">经过`2MSL`这个时间,**⾜以让两个⽅向上的数据包都被丢弃，使得原来连接的数据包在⽹络中都⾃然消失，再出现的数据包⼀定都是新建⽴连接所产⽣的**</mark>。

**原因二:保证连接正确关闭**

<mark style="color:blue">**TIME-WAIT 作⽤是等待⾜够的时间以确保最后的 ACK 能让被动关闭⽅接收，从⽽帮助其正常关闭**</mark>。

TIME-WAIT 没有等待时间或时间过短，断开连接会造成什么问题呢？

![image-20220222113009072](https://my-typora-pictures-1252258460.cos.ap-guangzhou.myqcloud.com/img/image-20220222113009072.png)

如果 TIME-WAIT 等待⾜够⻓的情况就会遇到两种情况:
- 服务端正常收到四次挥⼿的最后⼀个 ACK 报⽂，则服务端正常关闭连接。
- **服务端没有收到四次挥⼿的最后⼀个 ACK 报⽂时，则会重发 FIN 关闭连接报⽂并等待新的 ACK 报⽂**。

所以客户端在`TIME-WAIT`状态等待`2MSL`时间后，就可以保证双⽅的连接都可以正常的关闭。

#### 问题十二: TIME_WAIT 过多有什么危害？

如果服务器有处于`TIME-WAIT`状态的`TCP`，则说明是由服务器⽅主动发起的断开请求。
过多的`TIME-WAIT`状态主要的危害有两种:

- 第⼀是内存资源占⽤;
- 第⼆是对端⼝资源的占⽤，⼀个 TCP 连接⾄少消耗⼀个本地端⼝;

如果发起连接⼀⽅的 TIME_WAIT 状态过多，占满了所有端⼝资源，则会导致⽆法创建新连接。

#### 问题十三: 如何优化 TIME_WAIT？

**⽅式⼀:net.ipv4.tcp_tw_reuse 和 tcp_timestamps**
如下的 Linux 内核参数开启后，则可以复⽤处于`TIME_WAIT`的`socket`为新的连接所⽤。
有⼀点需要注意的是,`tcp_tw_reuse`功能只能⽤客户端(连接发起⽅),因为开启了该功能,在调⽤`connect()`函数时,内核会随机找⼀个`time_wait`状态超过 1 秒的连接给新的连接复⽤。
`net.ipv4.tcp_tw_reuse = 1`
使⽤这个选项，还有⼀个前提，需要打开对 TCP 时间戳的⽀持，即
`net.ipv4.tcp_timestamps=1(默认即为 1)`
这个时间戳的字段是在 TCP 头部的 **选项** ⾥，⽤于记录`TCP`发送⽅的当前时间戳和从对端接收到的最新时间戳。
由于引⼊了时间戳，我们在前⾯提到的 2MSL 问题就不复存在了，因为重复的数据包会因为时间戳过期被⾃然丢弃。

**⽅式⼆:`net.ipv4.tcp_max_tw_buckets`**
这个值默认为`18000`,当系统中处于`TIME_WAIT`的连接⼀旦超过这个值时，系统就会将后⾯的`TIME_WAIT`连接状态重置。
这个⽅法过于暴⼒，⽽且治标不治本，带来的问题远⽐解决的问题多，不推荐使⽤。

#### 问题十四:如果已经建⽴了连接，但是客户端突然出现故障了怎么办?
TCP 有⼀个机制是keepalive机制。
在Linux内核可以有对应的参数可以设置保活时间、保活探测的次数、保活探测的时间间隔，以下都为默认值:
```
net.ipv4.tcp_keepalive_time=7200
net.ipv4.tcp_keepalive_intvl=75
net.ipv4.tcp_keepalive_probes=9
```
- `tcp_keepalive_time=7200`:表示keepalive时间是`7200秒`(2⼩时)，也就2⼩时内如果没有任何连接相关的活动，则会启动keepalive机制;
- `tcp_keepalive_intvl=75`:表示每次检测间隔`75`秒;
- `tcp_keepalive_probes=9`:表示检测9次⽆响应,认为对⽅是不可达的,从⽽中断本次的连接。

也就是说在 Linux 系统中，最少需要经过 2 ⼩时 11 分 15 秒才可以发现⼀个「死亡」连接。

![image-20220222114739207](https://my-typora-pictures-1252258460.cos.ap-guangzhou.myqcloud.com/img/image-20220222114739207.png)

如果开启了 TCP 保活，需要考虑以下⼏种情况:
- **第⼀种，对端程序是正常⼯作的**。当 TCP 保活的探测报⽂发送给对端, 对端会正常响应，这样 TCP 保活时间会被重置，等待下⼀个 TCP 保活时间的到来。
- **第⼆种，对端程序崩溃并重启**。当 TCP 保活的探测报⽂发送给对端后，对端是可以响应的，但由于没有该连接的有效信息， 会产⽣⼀个 RST 报⽂，这样很快就会发现 TCP 连接已经被重置。
- **第三种，是对端程序崩溃，或对端由于其他原因导致报⽂不可达**。当 TCP 保活的探测报⽂发送给对端后，⽯沉⼤海，没有响应，连续⼏次，达到保活探测次数后， TCP 会报告该 TCP 连接已经死亡。

#### 问题十五: listen 时候参数 backlog 的意义？

Linux内核中会维护两个队列:
- 未完成连接队列(SYN队列)接收到⼀个 SYN 建⽴连接请求，处于 SYN_RCVD 状态；
- 已完成连接队列(Accpet队列):已完成 TCP 三次握⼿过程，处于 ESTABLISHED 状态；

![image-20220222120004692](https://my-typora-pictures-1252258460.cos.ap-guangzhou.myqcloud.com/img/image-20220222120004692.png)

`int listen(int socketfd,int backlog)`backlog 是 accept 队列长度。

**但是上限值是内核参数`somaxconn`的⼤⼩，也就说accpet队列⻓度 = min(backlog,somaxconn)**

#### 问题十六: accept 发⽣在三次握⼿的哪⼀步？

![image-20220222120305442](https://my-typora-pictures-1252258460.cos.ap-guangzhou.myqcloud.com/img/image-20220222120305442.png)

**客户端 connect 成功返回是在第⼆次握⼿，服务端 accept 成功返回是在三次握⼿成功之后**

#### 问题十六: 如果客户端第四次挥⼿ack丢失，服务端超时重发的fin报⽂也丢失，客户端timewait时间超过了2MSL，这个时候会发⽣什么？认为连接已经关闭吗？ 
- 当客户端 timewait 时间超过了 2MSL，则客户端就直接进⼊关闭状态;
- 服务端超时重发`FIN`报⽂的次数如果超过` tcp_orphan_retries` ⼤⼩后，服务端也会关闭 TCP 连接;

**读者问： “求教两个⼩问题：⽂章在解释IP分⽚和TCP MSS分⽚时说，如果⽤IP分⽚会有两个问题:**
**(1)IP按MTU分⽚，如果某⼀⽚丢失则需要所有分⽚都重传;**
**(2)IP没有重传机制，所以需要等TCP发送⽅超时才能重传;**
**问题⼀：MSS跟IP的MTU分⽚相⽐,只是多了⼀步协商MSS值的过程,⽽IP的MTU可以看作是默认协商好就是1500字节,所以为什么协商后的MSS可以做到丢失后只发丢失的这⼀⽚来提⾼效率，⽽默认协商好1500字节的IP分⽚就需要所有⽚都重传呢?**
**问题⼆： TCP MSS分⽚如果丢失了⼀⽚，是不是也需要发送⽅等待超时再重传？如果不是， MSS的协商如何能在超时前就直到丢了分⽚从⽽提⾼效率的呢？谢谢⽼师。**

- 问题一:
  - 如果⼀个⼤的TCP报⽂是被MTU分⽚,只有 **第⼀个分⽚** 才具有TCP头部,后⾯的分⽚则没有TCP头部，接收⽅IP层只有重组了这些分⽚，才会认为是⼀个TCP报⽂，那么丢失了其中⼀个分⽚，接收⽅IP层就不会把TCP报⽂丢给TCP层，那么就会等待对⽅超时重传这⼀整个 TCP 报⽂;
  - 如果⼀个⼤的TCP报⽂被MSS分⽚,那么所有`分⽚都具有TCP头部`,因为每个`MSS`分⽚的是具有TCP头部的TCP报⽂,那么其中⼀个`MSS` 分⽚丢失，就只需要重传这⼀个分⽚就可以;
- 问题二:
  - **TCP MSS分⽚如果丢失了⼀⽚,发送⽅没收到对⽅ACK应答,也是会触发超时重传的,因为TCP层是会保证数据的可靠交付**;

### 重传机制

TCP 实现可靠传输的⽅式之⼀，是通过序列号与确认应答。

#### 超时重传

TCP 会在以下两种情况发⽣超时重传：

- 数据包丢失;
- ACK 确认包丢失;

![image-20220222162319392](https://my-typora-pictures-1252258460.cos.ap-guangzhou.myqcloud.com/img/image-20220222162319392.png)

**超时时间应该设置为多少呢？**

`RTT`(Round-Trip Time): 往返时延，代表<mark style="color:blue">**网络从一端到另一端所需的时间**</mark>

![image-20220222162809678](https://my-typora-pictures-1252258460.cos.ap-guangzhou.myqcloud.com/img/image-20220222162809678.png)



`RTO`(Retransmission Timeout): 超时重传时间;

`RTO`过大 或 过小导致的问题:

- 当超时时间`RTO较⼤`时,重发就慢,丢了⽼半天才重发,没有效率,性能差；
- 当超时时间`RTO较⼩`时,会导致可能并没有丢就重发,于是重发的就快,会增加⽹络拥塞,导致更多的超时,更多的超时导致更多的重发;

<img src="https://my-typora-pictures-1252258460.cos.ap-guangzhou.myqcloud.com/img/image-20220222163513321.png" alt="image-20220222163513321" style="zoom:50%;" />

根据上述的两种情况，我们可以得知,<mark style="color:blue"> **超时重传时间 RTO 的值应该略⼤于报⽂往返 RTT 的值**</mark>。

**计算RTO的公式,这里就不细说。**

也就是<mark style="color:blue"> **每当遇到⼀次超时重传的时候，都会将下⼀次超时时间间隔设为先前值的两倍。两次超时，就说明⽹络环境差，不宜频繁反复发送**</mark>

#### 快速重传

<mark style="color:blue">**快速重传(Fast Retransmit)机制，不以时间为驱动，⽽是以数据驱动重传**</mark>

![image-20220222164005397](https://my-typora-pictures-1252258460.cos.ap-guangzhou.myqcloud.com/img/image-20220222164005397.png)

- Seq2因为某些原因丢失了,Seq3达到了,ACK返回2;
- 后面Seq4和Seq5都到了,ACK还是返回2,因为Seq2还没收到;
- <mark style="color:blue">**发送端收到了三个Ack=2的确认，知道了Seq2还没有收到，就会在定时器过期之前，重传丢失的 Seq2**</mark>;
- 最后，收到了Seq2,此时因为Seq3,Seq4,Seq5都收到了,于是Ack回6;

快速重传机制只解决了⼀个问题，就是超时时间的问题，但是它依然⾯临着另外⼀个问题。就是<mark style="color:blue">**重传的时候，是重传之前的⼀个，还是重传所有的问题**</mark>

是重传 Seq2 呢？还是重传 Seq2、 Seq3、 Seq4、 Seq5 呢？根据 TCP 不同的实现，以上两种情况都是有可能的。可⻅，这是⼀把双刃剑。为了解决不知道该重传哪些TCP报⽂,于是就有`SACK`⽅法。

#### SACK方法: Selective Acknowledgment 选择性确认

这种⽅式需要在TCP头部**"选项"**字段⾥加⼀个SACK 的东⻄，它<mark style="color:blue">**可以将缓存的地图发送给发送⽅**</mark>,这样发送⽅就可以知道哪些数据收到了，哪些数据没收到，知道了这些信息，就可以<mark style="color:blue">**只重传丢失的数据**</mark>。



![image-20220222165021661](https://my-typora-pictures-1252258460.cos.ap-guangzhou.myqcloud.com/img/image-20220222165021661.png)

如果要⽀持SACK,必须双⽅都要⽀持。在Linux下,可以通过`net.ipv4.tcp_sack`参数打开这个功能（Linux2.4 后默认打开）。

#### Duplicate SACK:`D-SACK`

`Duplicate SACK`⼜称`D-SACK`,其主要<mark style="color:blue">**使⽤了`SACK`来告诉 发送⽅ 有哪些数据被重复接收了**</mark>

**示例一:ACK丢包**

<img src="https://my-typora-pictures-1252258460.cos.ap-guangzhou.myqcloud.com/img/image-20220222165500599.png" alt="image-20220222165500599" style="zoom:50%;" />

- <mark style="color:blue">**接收⽅ 发现数据是重复收到的,于是回了⼀个SACK=3000~3500**</mark>,告诉「发送⽅」3000~3500的数据早已被接收了，因为 ACK 都到了 4000 了，已经意味着 4000 之前的所有数据都已收到，所以这个SACK 就代表着 D-SACK;
- 这样「发送⽅」就知道了，数据没有丢，是「接收⽅」的 ACK 确认报⽂丢了.

**示例二:网络延迟**

![image-20220222170203724](https://my-typora-pictures-1252258460.cos.ap-guangzhou.myqcloud.com/img/image-20220222170203724.png)

`D-SACK`有这么⼏个好处:
1. 可以让「发送⽅」知道，是发出去的包丢了，还是接收⽅回应的 ACK 包丢了(超时重传时);
2. 可以知道是不是「发送⽅」的数据包被⽹络延迟了(快速重传时);
3. 可以知道⽹络中是不是把「发送⽅」的数据包给复制了;

在Linux下可以通过`net.ipv4.tcp_dsack`参数开启/关闭这个功能(Linux2.4后默认打开).

### 滑动窗口

我们都知道`TCP`是每发送⼀个数据,都要进⾏⼀次确认应答。当上⼀个数据包收到了应答了,再发送下⼀个。 这种模式效率很低。
就像两个人面对面聊天，必须你一句，我一句。完全可以 你多说几句，我再回复。

TCP 引⼊了窗⼝这个概念;<mark style="color:blue">**窗⼝⼤⼩就是指⽆需等待确认应答，⽽可以继续发送数据的最⼤值**</mark>

假设窗⼝⼤⼩为3个TCP段,那么发送⽅就可以连续发送 3个TCP段,并且中途若有ACK丢失，可以通过「下⼀个确认应答进⾏确认」。如下图：

![image-20220222172526806](https://my-typora-pictures-1252258460.cos.ap-guangzhou.myqcloud.com/img/image-20220222172526806.png)

ACK 600 确认应答报⽂丢失，也没关系，因为可以通过下⼀个确认应答进⾏确认，只要发送⽅收到了 ACK 700 确认应答，就意味着 700 之前的所有数据「接收⽅」都收到了。这个模式就叫<mark style="color:blue">**累计确认或者累计应答**</mark>

**窗⼝⼤⼩由哪⼀⽅决定？**

TCP 头⾥有⼀个字段叫`Window`,也就是窗⼝⼤⼩。

<mark style="color:blue">**这个字段是接收端告诉发送端⾃⼰还有多少缓冲区可以接收数据。于是发送端就可以根据这个接收端的处理能⼒来发送数据，⽽不会导致接收端处理不过来**</mark>
所以，通常窗⼝的⼤⼩是由接收⽅的窗⼝⼤⼩来决定的。
**发送⽅发送的数据⼤⼩不能超过接收⽅的窗⼝⼤⼩，否则接收⽅就⽆法正常接收到数据**。

### 流量控制

发送⽅不能⽆脑的发数据给接收⽅，要考虑接收⽅处理能⼒。

TCP 提供⼀种机制可以让「发送⽅」根据「接收⽅」的实际接收能⼒控制发送的数据量，这就是所谓的流量控制。

#### 操作系统缓冲区与滑动窗⼝的关系

发送窗⼝和接收窗⼝中所存放的字节数，都是放在操作系统内存缓冲区中的，⽽操作系统的缓冲区，会<mark style="color:blue">**被操作系统调整**</mark>

如果接收方应用程序一直不读取走 接收窗口(缓冲区)中的数据，接收窗⼝大小会被缩小，甚至收缩为 0 了，也就是发⽣了窗⼝关闭。

当发送⽅可⽤窗⼝变为 0 时，发送⽅实际上会定时发送窗⼝探测报⽂，以便知道接收⽅的窗⼝是否发⽣了改变。

**窗口关闭**

在前⾯我们都看到了,TCP 通过**让接收⽅指明希望从发送⽅接收的数据⼤⼩(窗⼝⼤⼩)来进⾏流量控制**。

<mark style="color:blue">**如果窗⼝⼤⼩为0时，就会阻⽌发送⽅给接收⽅传递数据，直到窗⼝变为⾮ 0 为⽌，这就是窗⼝关闭**</mark>

**窗⼝关闭潜在的危险**

接收⽅向发送⽅通告窗⼝⼤⼩时，是通过 ACK 报⽂来通告的。
那么，当发⽣窗⼝关闭时，接收⽅处理完数据后，会向发送⽅通告⼀个窗⼝⾮0的ACK报⽂，如果这个通告窗⼝的 ACK 报⽂在⽹络中丢失了，那麻烦就⼤了。

![image-20220222192648946](https://my-typora-pictures-1252258460.cos.ap-guangzhou.myqcloud.com/img/image-20220222192648946.png)

这会导致发送⽅⼀直等待接收⽅的⾮ 0 窗⼝通知，接收⽅也⼀直等待发送⽅的数据，如不采取措施，这种相互等待的过程，会造成了死锁的现象。

**TCP 是如何解决窗⼝关闭时，潜在的死锁现象呢？**

为了解决这个问题， TCP 为每个连接设有⼀个持续定时器,<mark style="color:blue">**只要 TCP 连接⼀⽅收到对⽅的零窗⼝通知，就启动持续计时器**</mark>

如果持续计时器超时，就会发送<mark style="color:blue">**窗⼝探测(Window probe)报⽂,⽽对⽅在确认这个探测报⽂时,给出⾃⼰现在的接收窗⼝⼤⼩**</mark>。

![image-20220222193028442](https://my-typora-pictures-1252258460.cos.ap-guangzhou.myqcloud.com/img/image-20220222193028442.png)

窗⼝探测的次数⼀般为`3`次,每次⼤约`30-60`秒(不同的实现可能会不⼀样)。

如果`3`次过后接收窗⼝还是`0`的话,有的`TCP`实现就会发`RST`报⽂来中断连接。

### 拥塞控制

前⾯的流量控制是避免「发送⽅」的数据填满「接收⽅」的缓存，但是并不知道⽹络的中发⽣了什么。

<mark style="color:blue">**在⽹络出现拥堵时，如果继续发送⼤量数据包，可能会导致数据包时延、丢失等，这时 TCP 就会重传数据，但是⼀重传就会导致⽹络的负担更重，于是会导致更⼤的延迟以及更多的丢包，这个情况就会进⼊恶性循环被不断地放⼤....**</mark>

所以， TCP 不能忽略⽹络上发⽣的事，它被设计成⼀个⽆私的协议,当⽹络发送拥塞时,TCP会⾃我牺牲，降低发送的数据量。
于是，就有了<mark style="color:blue">**拥塞控制**</mark>，控制的⽬的就是<mark style="color:blue">**避免「发送⽅」的数据填满整个⽹络**</mark>

**什么是拥塞窗⼝？和发送窗⼝有什么关系呢？**
拥塞窗⼝`cwnd`是发送⽅维护的⼀个的状态变量,它会根据<mark style="color:blue">**⽹络的拥塞程度动态变化的**</mark>

我们在前⾯提到过发送窗⼝`swnd`和接收窗⼝`rwnd`是约等于的关系，那么由于加⼊了拥塞窗⼝的概念后，此时发送窗⼝的值是`swnd = min(cwnd, rwnd)`。

**那么怎么知道当前⽹络是否出现了拥塞呢?**

其实只要「发送⽅」没有在规定时间内接收到ACK应答报⽂,也就是<mark style="color:blue">**发⽣了超时重传,就会认为⽹络出现了⽤拥塞**</mark>

**拥塞控制有哪些控制算法?**

#### **慢启动**
慢启动的意思就是⼀点⼀点的提⾼发送数据包的数量。
慢启动的算法记住⼀个规则就⾏:当发送⽅每收到⼀个ACK，拥塞窗⼝cwnd的⼤⼩就会加1。

**那慢启动涨到什么时候是个头呢？**
有⼀个叫慢启动⻔限`ssthresh`(slow start threshold)`状态变量,⼀般来说`ssthresh`的⼤⼩是65535字节

- 当`cwnd`<`ssthresh`时，使⽤慢启动算法;
- 当`cwnd`>=`ssthresh`时，就会使⽤**拥塞避免算法**;

#### 拥塞避免算法
拥塞避免算法后,它的规则是:<mark style="color:blue">**每当收到⼀个`ACK`时,`cwnd`增加`1/cwnd`**</mark>

#### 拥塞发⽣
当⽹络出现拥塞，也就是会发⽣数据包重传，重传机制主要有两种:
- 超时重传;
- 快速重传;

**发⽣超时重传的拥塞发⽣算法**
当发⽣了「超时重传」，则就会使⽤拥塞发⽣算法。这个时候,`ssthresh`和`cwnd`的值会发⽣变化。

- `ssthresh`设置为`cwnd/2`;
- `cwnd`重置为1;

接着，就重新开始慢启动，慢启动是会突然减少数据流的。这真是⼀旦「超时重传」，⻢上回到解放前。但是这种⽅式太激进了，反应也很强烈，会造成⽹络卡顿。

**发⽣快速重传的拥塞发⽣算法**
当接收⽅发现丢了⼀个中间包的时候，发送三次前⼀个包的ACK，于是发送端就会快速地重传，不必等待超时再重传。

TCP 认为这种情况不严重，因为⼤部分没丢，只丢了⼀⼩部分,则`ssthresh`和`cwnd`变化化如下:
- `cwnd=cwnd/2`,也就是设置为原来的⼀半;
- `ssthresh=cwnd`;
- 进⼊快速恢复算法;

#### 快速恢复
**快速重传**和**快速恢复**算法⼀般同时使⽤,**快速恢复**算法是认为，你还能收到3个重复ACK说明⽹络也不那么糟糕,所以没有必要像`RTO`超时那么强烈。

快速恢复之前,`cwnd`和`ssthresh`已被更新了:
- `cwnd=cwnd/2`,也就是设置为原来的⼀半;
- `ssthresh=cwnd`;

然后，进⼊快速恢复算法如下:
- 拥塞窗⼝`cwnd=ssthresh+3`,(3的意思是确认有3个数据包被收到了);
- 重传丢失的数据包;
- 如果再收到重复的ACK(duplicated Acks),那么cwnd增加1;
- 如果收到新数据的`ACK`后,把`cwnd`设置为第⼀步中的`ssthresh`的值,原因是该`ACK`确认了新的数据,说明从`duplicated ACK` 时的数据都已收到,该恢复过程已经结束,可以回到恢复之前的状态了，也即再次进⼊ **拥塞避免状态**;